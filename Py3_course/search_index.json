[["index.html", "Python3学习教程 Hello", " Python3学习教程 陈同 chentong_biology@163.com 2025-11-03 Hello 生信的作用越来越大，想学的人越来越多，不管是为了以后发展，还是为了解决眼下的问题。但生信学习不是一朝一夕就可以完成的事情，也许你可以很短时间学会一个交互式软件的操作，却不能看完程序教学视频后就直接写程序。也许你可以跟着一个测序分析流程完成操作，但不懂得背后的原理，不知道什么参数需要修改，结果可以出来，却把握不住对还是错。 学习生信从来就不是一个简单的事，需要做好持久战的心理准备。 在学习时，我们都希望由浅入深的逐步深入，不断地练习和实践，这就是为什么我们需要一本书，因为书很系统。但生信发展的历史短于计算机编程的历史，如果想要一门程序设计的入门数据，每种语言都可以找到几本。但想要一个囊括生信的书，就有些难了。本身生信跨领域，需要多学科的知识，而其内部又有不少分子，都囊括了太大，包括的少又有些隔靴搔痒的感觉。 我们当时都是零基础下自学Linux, 自学Python，自学R，自学高通量测序；这些学习经历，之前都零星地记录在博客里。现在回头去看几年前自己记录的东西，觉得好简单，而当时却费了很大的力气。这些零星的随手记，当时也只是为了自己看，到现在确实只有自己能看得懂，不便惠及更多的人。 因此我们创建了生信宝典，希望从不同的角度传播知识。这个不同有三点含义，一是形式上的不同，摒弃之前主编们单人作战想写啥就写啥，而是有组织有计划的内容聚合，提供一系列的教程，由入门到提高。二是内容的不同，不去用网上现有教程的通用数据做例子，而是拿实际生物数据，讲述如何解释生信中普遍碰到的问题，讲述如何处理自己的数据。三是立足点不同。在写作时，我们回到了当年，在回忆中用整个阶段的学习去指导当初的那个小白，从那些会了的人觉得微不足道而不会的人又迈不过的坎入手，直击痛点。知识点的收录依据不是是否炫酷，是否难，而是是否必要。如果必要，再简单，也要提及；如果不必要，再炫酷，也暂不纳入。 通过大量的生信例子、关键的注释和浓缩的语句形成下面的一系列学习教程。每一篇内容都不多，可以当做小说阅读，也可以跟着去练，反复几遍，每读一次都会有不同的收获和体会。 "],["pythonbasic.html", "1 Python基础 1.1 交互模式下表达式 1.2 Python中的数据类型：整数（int）、浮点（float）和字符串（str） 1.3 字符串的连接和复制 1.4 变量 1.5 第一小程序HelloWorld.py 1.6 逻辑和比较操作 1.7 控制流 1.8 导入模块 1.9 函数： 内置函数、自定义函数 1.10 局部和全局作用域 1.11 声明为全局变量global 1.12 异常的处理 1.13 列表 1.14 字符串和元组 1.15 引用 1.16 字典 键：值 对 1.17 字典与列表 1.18 字符串操作", " 1 Python基础 王绪宁制作 1.1 交互模式下表达式 #表达式： 值、操作符优先级 2 + 2 4 2 + 3 * 5 17 ( 2 + 3 ) * 5 25 23 % 7 #取余数，判断数据是奇数还是偶数时应用 2 23 // 7 # 3 #示例报错，语法要符合规则，像英语语法规则一样。 2+ File &quot;&lt;ipython-input-9-d066253e063d&gt;&quot;, line 2 2+ ^ SyntaxError: invalid syntax 1.2 Python中的数据类型：整数（int）、浮点（float）和字符串（str） type(2) int type(2.5) float int(2.4) 2 type(&#39;Hello, world！&#39;) #字符串用成对的引号（单引号、双引号、三引号） str #如果字符串没有引号，则报错 ‘hello，world File &quot;&lt;ipython-input-16-874a8e2fccea&gt;&quot;, line 2 ‘hello，world ^ SyntaxError: invalid character in identifier 1.3 字符串的连接和复制 &#39;Hello&#39; + &#39;world!&#39; &#39;helloworld!&#39; &#39;hello&#39; + 21 #错误示例，两个字符串才能相加 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-18-2f37c7cd8411&gt; in &lt;module&gt;() ----&gt; 1 &#39;hello&#39;+21 TypeError: must be str, not int &#39;hello&#39; + &#39;21&#39; &#39;hello21&#39; &#39;Hello&#39; * 5 #必须是整数,才可复制 &#39;HelloHelloHelloHelloHello&#39; &#39;hello&#39;*5.0 #错误示例 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-21-8dc053398ad8&gt; in &lt;module&gt;() ----&gt; 1 &#39;hello&#39;*5.0 TypeError: can&#39;t multiply sequence by non-int of type &#39;float&#39; 多个字符串的合并使用+不是最好的方式，大家想想为什么？ 有什么更好的方式呢？ 参见文章为啥我的Python这么慢 (一)。 1.4 变量 #变量就像一个盒子一样 a = 5 a 5 b = 3 b 3 a + b 8 #第一次赋值为变量的初始化，再次赋值则被覆写 a = 30 a 30 c = &#39;hello&#39; c &#39;hello&#39; c = &#39;goodbye&#39; c &#39;goodbye&#39; # 变量名命名:为清晰表达，驼峰式，下划线式 LookLikeThis = 1 look_like_this = &#39;a&#39; 1.5 第一小程序HelloWorld.py # 第一小程序的准备 #注释用# # print() #打印内容显示在屏幕上 print(&#39;python&#39;) a = 5 print(a) # 打印变量 python myName = input() a myName = input(&#39;please type your name！\\n&#39;) please type your name！ python #len()查看字符串的个数 len(&#39;hello&#39;) len(&#39;hell o&#39;) 6 ##类型转换的函数 str() int() float() 0.0 str(8) &#39;8&#39; int(2.5) 2 float(2) 2.0 42 == &#39;42&#39; #字符和数字不同 False #特殊的值None,函数部分会再次提及此值 type(None) NoneType None == 42 False #This is my second python pargram！ myName=input(&#39;What is your name?&#39;) print (&#39;It is good to meet you,&#39; + myName) print (&#39;The length of your name is &#39;+ str(len(myName))) print(&#39;What is your age?&#39;) myAge=input() print (&#39;You will be &#39; + str( int( myAge)+1 )+ &#39; in a year.&#39;) What is your name?wang It is good to meet you,wang The length of your name is 4 What is your age? 2 You will be 3 in a year. #如上是在交互模式下的运行，那写好脚本如何运行呢？ import os os.getcwd() &#39;F:\\\\mega\\\\python\\\\python&#39; os.chdir(&#39;F:\\\\mega\\\\python\\\\python&#39;) os.getcwd() &#39;F:\\\\mega\\\\python\\\\python&#39; #同时展示IPython模式下运行程序 %run helloworld.py 1.6 逻辑和比较操作 1.6.1 布尔逻辑值 a = False a False b = True b True 1.6.2 比较操作符 42 == 21 False 42 == &#39;42&#39; False 2 != 1 True a = &#39;hello&#39; a == &#39;hello&#39; True a == &#39;goodbye&#39; False 1.6.3 布尔操作符 and or not True and True True True &amp; False False not False True not not True True 1.6.4 布尔操作和比较操作符 ( 3 &gt; 2 ) and ( 5 &lt; 6 ) True ( 3 &lt; 2 ) or ( 5 &lt; 6 ) True 1.7 控制流 # 条件 name = input(&#39;Please enter a name\\n&#39;) if name == &#39;python&#39;: print(&#39;hello python&#39;) else: print(&#39;You are not python&#39;) Please enter a name python hello python 1.7.1 if 语句 if 条件（True or False） ： 代码块1 else ： 代码块2 1.7.2 elif 否则如果 elif 条件 ： 代码块 age = int(input(&#39;please enter your age!\\n&#39;)) # input()从屏幕中录入的内容，属于字符串类型 if age &lt; 18: print(&#39;Hi, kids&#39;) elif 40 &gt;= age &gt;= 12: print(&#39;Hi, young man&#39;) elif age &gt; 40: print(&#39;Hi, old man&#39;) please enter your age! 34 Hi, young man 1.7.3 while循环 a = 0 if a &lt; 5: print(&#39;Hello, world&#39;) a = a + 1 Hello, world a = 0 while a &lt; 5: print(&#39;Hello, world&#39;) a = a + 1 Hello, world Hello, world Hello, world Hello, world Hello, world name = &#39;&#39; while name != &#39;Your name&#39;: name = input(&#39;Enter your name\\n&#39;) print(&#39;Thank you&#39;) Enter your name your name Thank you 1.7.4 break和continue while True: name = input(&#39;Please enter your name!\\n&#39;) if name == &#39;Your name&#39;: break # 跳出循环 print(&#39;You are right!&#39;) Please enter your name! Your name You are right! # 模拟登陆账号 while True: name = input(&#39;Who are you?\\n&#39;) if name != &#39;Bob&#39;: continue # 将程序跳转到开头 print(&#39;Hello, Bob. What is your password?&#39;) password = input() if password == &#39;fish&#39;: break print(&#39;Access granted!&#39;) Who are you? Bob Hello, Bob. What is your password? fish Acess granted! 1.7.5 for 和 range（）函数 # for 和 range（）实现固定的循环次数 for i in range(5): print(i) print(&#39;Hello world&#39;) 0 Hello world 1 Hello world 2 Hello world 3 Hello world 4 Hello world # 等价的while循环 i = 0 while i &lt; 5: print(i) print(&#39;Hello world&#39;) i = i + 1 0 Hello world 1 Hello world 2 Hello world 3 Hello world 4 Hello world # 高斯的1+2+3+...+100=? total = 0 for i in range(101): total = total + i print(total) 5050 # 高斯的1+2+3+...+100=? total = 0 for i in range(101): total += i print(total) 5050 1.7.6 range()函数（开始，停止，步长） for i in range(1, 10, 2): print(i) 1 3 5 7 9 help(range) Help on class range in module builtins: class range(object) | range(stop) -&gt; range object | range(start, stop[, step]) -&gt; range object | | Return an object that produces a sequence of integers from start (inclusive) | to stop (exclusive) by step. range(i, j) produces i, i+1, i+2, ..., j-1. | start defaults to 0, and stop is omitted! range(4) produces 0, 1, 2, 3. | These are exactly the valid indices for a list of 4 elements. | When step is given, it specifies the increment (or decrement). | | Methods defined here: | | __contains__(self, key, /) | Return key in self. | | __eq__(self, value, /) | Return self==value. | | __ge__(self, value, /) | Return self&gt;=value. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __getitem__(self, key, /) | Return self[key]. | | __gt__(self, value, /) | Return self&gt;value. | | __hash__(self, /) | Return hash(self). | | __iter__(self, /) | Implement iter(self). | | __le__(self, value, /) | Return self&lt;=value. | | __len__(self, /) | Return len(self). | | __lt__(self, value, /) | Return self&lt;value. | | __ne__(self, value, /) | Return self!=value. | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | __reduce__(...) | helper for pickle | | __repr__(self, /) | Return repr(self). | | __reversed__(...) | Return a reverse iterator. | | count(...) | rangeobject.count(value) -&gt; integer -- return number of occurrences of value | | index(...) | rangeobject.index(value, [start, [stop]]) -&gt; integer -- return index of value. | Raise ValueError if the value is not present. | | ---------------------------------------------------------------------- | Data descriptors defined here: | | start | | step | | stop for i in range(5, -1, -1): print(i) 5 4 3 2 1 0 # 脑筋急转弯，题目如下 # 100元钱，5元铅笔盒，3元一只笔，0.5元一块橡皮，将100元花完，同时三种物品的个数和为100，请用编程解决 # 假设铅笔盒为x个，笔为y只，橡皮z个 print(&quot;x y z&quot;) for x in range(1, 101): for y in range(1, 101): for z in range(1, 101): if x + y + z == 100 and 5 * x + 3 * y + 0.5 * z == 100: print(x, y, z) x y z 5 11 84 10 2 88 1.8 导入模块 import random # 当多个模块时，用逗号隔开 for i in range(5): print(random.randint(1, 10)) 2 9 2 4 10 import random as rd for i in range(5): print(rd.randint(1, 10)) 2 8 5 7 7 from random import randint for i in range(5): print(randint(1, 10)) 6 8 5 6 2 import sys import os import math # 综合小例子，控制流的结束，执行完成本身即可结束 import sys while True: print(&#39;type exit to exit.&#39;) response = input() if response == &#39;exit&#39;: sys.exit() # 退出Python程序 print(&#39;Let us have a short break!&#39;) type exit to exit. exit An exception has occurred, use %tb to see the full traceback. SystemExit C:\\Users\\Administrator\\Anaconda3\\lib\\site-packages\\IPython\\core\\interactiveshell.py:2870: UserWarning: To exit: use &#39;exit&#39;, &#39;quit&#39;, or Ctrl-D. warn(&quot;To exit: use &#39;exit&#39;, &#39;quit&#39;, or Ctrl-D.&quot;, stacklevel=1) 1.9 函数： 内置函数、自定义函数 1.9.1 函数print（），len （）,input （），int（），str（）均为内置函数 help(print) Help on built-in function print in module builtins: print(...) print(value, ..., sep=&#39; &#39;, end=&#39;\\n&#39;, file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. print(&#39;a&#39;, &#39;b&#39;) a b # 自定义函数 def sum(a, b): c = a + b print(c) sum(3, 4) 7 def sum(a, b): # a,b为自定义函数中的两个参数 c = a + b return c sum(1, 3) 4 import random def getAnswer(answerNumber): if answerNumber == 1: return &#39;It is certain&#39; elif answerNumber == 2: return &#39;It is decidely so&#39; elif answerNumber == 3: return &#39;Yes&#39; elif answerNumber == 4: return &#39;Reply hazy try again&#39; elif answerNumber == 5: return &#39;Ask again later&#39; elif answerNumber == 6: return &#39;Concentrate and ask again&#39; elif answerNumber == 7: return &#39;My reply is no&#39; elif answerNumber == 8: return &#39;Outlook not so good&#39; elif answerNumber == 9: return &#39;Very doubtful&#39; r = random.randint(1, 9) fortune = getAnswer(r) print(r, fortune) 8 Outlook not so good # 关于None的值 print() # 打印内容为空，所以为None，其他编程语言可能为NA，null等 print(&#39;cat&#39;, &#39;dog&#39;, &#39;mice&#39;) # 位置参数 cat dog mice print(&#39;cat&#39;, &#39;dog&#39;, &#39;mice&#39;, sep=&#39;*&#39;, end=&#39;88888&#39;) # end，sep就是关键字参数 cat*dog*mice88888 1.10 局部和全局作用域 全局作用：函数之外。 局部作用：函数之内。 局部可以访问全局变量，而全局不能使用局部变量。 def spam(): eggs = 1000 return eggs spam() 1000 eggs #报错：eggs未被定义，因为eggs是自定义函数spam()中的局部变量 --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-90-6eaa7316e4ae&gt; in &lt;module&gt;() ----&gt; 1 eggs NameError: name &#39;eggs&#39; is not defined # 同理局部变量不能使用其他局部变量 def python(): eggs = 99 spam() print(eggs) def spam(): eggs = 0 return eggs python() 99 spam() 0 # 全局变量在局部作用域中使用 def spam(): print(eggs) eggs = 28 spam() 28 print(eggs) 28 # 尽量避免名称相同的局部变量和全局变量 def spam(): eggs = &#39;spam local&#39; print(eggs) # 输出spam local def bacon(): eggs = &#39;bacon local&#39; print(eggs) # 输出bacon local spam() print(eggs) # 输出bacon local eggs = &#39;global&#39; bacon() bacon local spam local bacon local print(eggs) global 1.11 声明为全局变量global # 在函数内修改全局变量 def spam(): global eggs # 声明为全局变量 eggs = 5 eggs = 7 spam() # 调用自定义函数spam() print(eggs) 5 def spam(): global eggs # this is the global eggs = &#39;spam&#39; def bacon(): eggs = &#39;bacon&#39; # this is a local def ham(): print(eggs) # this is the global eggs = 42 # this is the global spam() print(eggs) spam 1.12 异常的处理 自定义函数可能报错，报错的处理 def spam(divideBy): return 21 / divideBy spam(3) spam(7) 3.0 spam(0) # 如果是0，则会报错 --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) &lt;ipython-input-107-b3fca5f67bd4&gt; in &lt;module&gt;() ----&gt; 1 spam(0) &lt;ipython-input-106-f3d08c8e42a5&gt; in spam(divideBy) 1 def spam(divideBy): ----&gt; 2 return 21/divideBy 3 spam(3) 4 spam(7) ZeroDivisionError: division by zero # 此时，我们可以借助try 和 except解决 def spam(divideBy): try: return 21 / divideBy except ZeroDivisionError: print(&#39;Error: invalid argument&#39;) spam(0) spam(3) Error: invalid argument 7.0 # 以上为知道报错内容，如果不知道报错内容呢？ def spam(divideBy): try: return 21 / divideBy except: print(&#39;Error: invalid argument&#39;) spam(0) Error: invalid argument import traceback def spam(divideBy): try: return 21 / divideBy except: traceback.print_exc() spam(0) Traceback (most recent call last): File &quot;&lt;ipython-input-115-9238a8901fff&gt;&quot;, line 4, in spam return 21/ divideBy ZeroDivisionError: division by zero # 用sys模块 import sys def spam(divideBy): try: return 21 / divideBy except: info = sys.exc_info() #print (info) print(info[0], &quot;:&quot;, info[1]) spam(0) &lt;class &#39;ZeroDivisionError&#39;&gt; : division by zero # 只有6次机会的猜字游戏 # This is a guess the number game. import random secretNumber = random.randint(1, 20) print(&#39;I am thinking of a number between 1 and 20.&#39;) # Ask the player to guess 6 times. for guessesTaken in range(1, 7): print(&#39;Take a guess.&#39;) guess = int(input()) if guess &lt; secretNumber: print(&#39;Your guess is too low.&#39;) elif guess &gt; secretNumber: print(&#39;Your guess is too high.&#39;) else: break # This condition is the correct guess! if guess == secretNumber: print(&#39;Good job! You guessed my number in &#39; + str(guessesTaken) + &#39; guesses!&#39;) else: print(&#39;Nope. The number I was thinking of was &#39; + str(secretNumber)) I am thinking of a number between 1 and 20. Take a guess. 1 Your guess is too low. Take a guess. 6 Your guess is too low. Take a guess. 5 Your guess is too low. Take a guess. 3 Your guess is too low. Take a guess. 4 Your guess is too low. Take a guess. 6 Your guess is too low. Nope. The number I was thinking of was 7 # collatz序列，如果是偶数则打印n//2， 如果是奇数则打印3*n+1 def collatz(n): print(n) if n % 2 == 1 and n &gt; 1: collatz(3 * n + 1) elif n % 2 == 0: collatz(n // 2) n = input(&#39;enter a number:&#39;) n = int(n) collatz(n) enter a number:4 4 2 1 1.13 列表 “列表”是一个值，比如[1,3,3,‘cat’] type([1, 2, &#39;a&#39;]) list a = [1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;] a [1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;] b = [a, 3, 4] # 列表可以嵌套列表，字典等 b [[1, 2, 3, 4, &#39;a&#39;, &#39;b&#39;], 3, 4] 取列表中单个值 a = [i for i in range(5)] a [0, 1, 2, 3, 4] a[0] # 用元素的下标取值 0 a[3] 3 zoo = [&#39;cat&#39;, &#39;dog&#39;, &#39;rat&#39;, &#39;elephant&#39;] zoo[3] &#39;elephant&#39; zoo[0:2] [&#39;cat&#39;, &#39;dog&#39;] &#39;hello &#39; + zoo[3] &#39;hello elephant&#39; 负数下标 zoo[-1] &#39;elephant&#39; a = [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] zoo = [&#39;cat&#39;, &#39;dog&#39;, &#39;rat&#39;, &#39;elephant&#39;] total = [a, zoo] total [[&#39;b&#39;, &#39;c&#39;, &#39;d&#39;], [&#39;cat&#39;, &#39;dog&#39;, &#39;rat&#39;, &#39;elephant&#39;]] total[0][1] &#39;c&#39; total[1][0] &#39;cat&#39; zoo[0] 列表和下标 zoo[0:2]列表和切片 zoo[0:2] [&#39;cat&#39;, &#39;dog&#39;] zoo[100] #超出后报错 --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-13-034b9400bdc5&gt; in &lt;module&gt;() ----&gt; 1 zoo[100] IndexError: list index out of range 查看列表长度 len(zoo) 4 # 用下标更改列表的值 zoo = [&#39;cat&#39;, &#39;dog&#39;, &#39;rat&#39;, &#39;elephant&#39;] zoo [&#39;cat&#39;, &#39;dog&#39;, &#39;rat&#39;, &#39;elephant&#39;] zoo[0] = &#39;five&#39; zoo [&#39;five&#39;, &#39;dog&#39;, &#39;rat&#39;, &#39;elephant&#39;] 列表的连接和复制 a = [i for i in range(5)] a [0, 1, 2, 3, 4] b = [i for i in range(3, 10, 2)] b [3, 5, 7, 9] a + b [0, 1, 2, 3, 4, 3, 5, 7, 9] a * 3 # 列表的复制 [0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4] 删除某个元素 del a[0] #删除运行中的某个变量 a [1, 2, 3, 4] del a[2] a [1, 2, 4] # 应用列表的实例 bookNames = [] while True: print(&#39;Enter the name of books&#39; + str(len(bookNames) + 1) + &#39;Or enter nothing to stop&#39;) name = input() if name == &#39;&#39;: break bookNames = bookNames + [name] print(&#39;The books are:\\n&#39;) for name in bookNames: print(&#39; &#39; + name) enter the name of books1Or enter nothing to stop lives enter the name of books2Or enter nothing to stop python enter the name of books3Or enter nothing to stop linux enter the name of books4Or enter nothing to stop The books are: lives python linux 列表在循环中的应用 for i in range(5): print(i) 0 1 2 3 4 for i in [0, 1, 2, 3, 4]: print(i) 0 1 2 3 4 in 和 not in操作 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] &#39;python&#39; in tool True &#39;C&#39; not in tool True 应用列表多重赋值 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] first = tool[0] second = tool[1] third = tool[2] forth = tool[3] print(first, second, third, forth) python R perl java # 另一种方式 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] first, second, third, forth = tool print(first, second, third, forth) python R perl java 增强的赋值操作 ### += -= *= %= 注意：+= *=可以完成字符串连接和复制 a = 32 a += 1 # 等价于a = a + 1 a 33 方法和函数是一回事，每个数据类型都有一些自己的一组方法。列表数据：查找、添加、删除或操作列表值 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] tool.index(&#39;R&#39;) 1 tool.index(&#39;perl&#39;) 2 tool.index(&#39;C&#39;) # 没有在list中的情况 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-44-385ebd06ddfe&gt; in &lt;module&gt;() ----&gt; 1 tool.index(&#39;C&#39;) ValueError: &#39;C&#39; is not in list # 添加 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] tool.append(&#39;C&#39;) # 没执行一次就多一个 tool [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;, &#39;C&#39;] # 插入 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] tool.insert(1, &#39;C&#39;) tool [&#39;python&#39;, &#39;C&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] # 插入和添加，只能在列表上用 &#39;str&#39; object has no attribute &#39;append&#39; eggs = &#39;hello&#39; eggs.append(&#39;o&#39;) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-51-f76c80edd988&gt; in &lt;module&gt;() 1 #插入和添加，只能在列表上用 2 eggs=&#39;hello&#39; ----&gt; 3 eggs.append(&#39;o&#39;) AttributeError: &#39;str&#39; object has no attribute &#39;append&#39; # 插入和添加，只能在列表上用 &#39;str&#39; object has no attribute &#39;insert&#39; eggs = &#39;hello&#39; eggs.insert(1, &#39;o&#39;) --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-52-21aceb5fda09&gt; in &lt;module&gt;() 1 #插入和添加，只能在列表上用 &#39;str&#39; object has no attribute &#39;append&#39; 2 eggs=&#39;hello&#39; ----&gt; 3 eggs.insert(1,&#39;o&#39;) AttributeError: &#39;str&#39; object has no attribute &#39;insert&#39; # 删除 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] tool.remove(&#39;java&#39;) tool [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;] # 删除不存在的值将报错 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] tool.remove(&quot;C&quot;) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-54-c1e62b8d0701&gt; in &lt;module&gt;() 1 #删除不存在的值将报错 2 tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39; ] ----&gt; 3 tool.remove(&quot;C&quot;) ValueError: list.remove(x): x not in list # 对列表的值进行排序 lt = [1, 32, 4, 7, 5] lt.sort() lt [1, 4, 5, 7, 32] lt.sort(reverse=True) lt [32, 7, 5, 4, 1] lt = [1, 9, 2, &#39;a&#39;] # 不同类型不可排序,sort()使用ASCII码进行排序，因此小写a在Z之前 lt.sort() --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-89-69cf80e7b764&gt; in &lt;module&gt;() 1 lt=[1,9,2,&#39;a&#39;]#不同类型不可排序,sort()使用ASCII码进行排序，因此小写a在Z之前 ----&gt; 2 lt.sort() TypeError: &#39;&lt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39; 1.14 字符串和元组 name = &#39;python&#39; name[0:2] &#39;py&#39; name[-1] &#39;n&#39; &#39;p&#39; in name True &#39;p&#39; not in name False for i in name: print (i) p y t h o n # 元组tuple,不可修改 eggs = (1, 2, &#39;a&#39;) type(eggs) tuple # 不可修改 eggs[1] = &#39;python&#39; --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-71-d14153220c16&gt; in &lt;module&gt;() ----&gt; 1 eggs[1]=&#39;python&#39; TypeError: &#39;tuple&#39; object does not support item assignment eggs[1] 2 #元组用（），列表[]，注意区分如下情况 type((&#39;hello&#39;)) str type((&#39;hello&#39;,)) #逗号在元组中其“重要作用” tuple tool = [&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;] tuple(tool) (&#39;python&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;java&#39;) a = (1, 3, 4) list(a) [1, 3, 4] 1.15 引用 a = 42 b = a a = 100 a 100 b 42 列表的引用 a = [i for i in range(5)] a [0, 1, 2, 3, 4] b = a b [0, 1, 2, 3, 4] a[0] = &#39;hello&#39; a [&#39;hello&#39;, 1, 2, 3, 4] b [&#39;hello&#39;, 1, 2, 3, 4] import copy # 列表的复制 a = [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] a [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] f = copy.copy(a) f [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] f[0] = &#39;python&#39; f [&#39;python&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] a [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] deep.copy()如果列表中包含了列表，使用deepcopy() a = [1, 2, 4, 6, [7, 9]] b = copy.copy(a) b [1, 2, 4, 6, [7, 9]] a[-1][0] = 70 b [1, 2, 4, 6, [70, 9]] a = [1, 2, 4, 6, [7, 9]] b = copy.deepcopy(a) b [1, 2, 4, 6, [7, 9]] a[-1][0] = 111 a [1, 2, 4, 6, [111, 9]] b [1, 2, 4, 6, [7, 9]] 1.16 字典 键：值 对 myTool = {&#39;first&#39;: &#39;python&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;, &#39;forth&#39;: &#39;perl&#39;} myTool {&#39;first&#39;: &#39;python&#39;, &#39;forth&#39;: &#39;perl&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;} myTool[&#39;first&#39;] &#39;python&#39; 1.17 字典与列表 # 默认字典是不排序的,不能应用下标或者切片取出，而列表是有序列的 a = [1, 2, 3] b = [2, 1, 3] a == b False myTool1 = {&#39;first&#39;: &#39;python&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;, &#39;forth&#39;: &#39;perl&#39;} myTool2 = {&#39;first&#39;: &#39;python&#39;, &#39;third&#39;: &#39;linux&#39;, &#39;second&#39;: &#39;R&#39;, &#39;forth&#39;: &#39;perl&#39;} myTool1 == myTool2 True #取值通过键 myTool[&#39;second&#39;] --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-27-ac22a2f1a4f0&gt; in &lt;module&gt;() 1 #取值通过键 ----&gt; 2 myTool[&#39;second&#39;] NameError: name &#39;myTool&#39; is not defined # 综合小程序 birthdays = {&#39;Alice&#39;: &#39;Apr 1&#39;, &#39;Bob&#39;: &#39;Dec 12&#39;, &#39;Carol&#39;: &#39;Mar 4&#39;} while True: print(&#39;Enter a name: (blank to quit)&#39;) name = input() if name == &#39;&#39;: break if name in birthdays: print(birthdays[name] + &#39; is the birthday of &#39; + name) else: print(&#39;I do not have birthday information for &#39; + name) print(&#39;What is their birthday?&#39;) bday = input() birthdays[name] = bday print(&#39;Birthday database updated.&#39;) Enter a name: (blank to quit) Alice Apr 1 is the birthday of Alice Enter a name: (blank to quit) wang I do not have birthday information for wang What is their birthday? Oct 1 Birthday database updated. Enter a name: (blank to quit) wang Oct 1 is the birthday of wang Enter a name: (blank to quit) 1.17.1 keys()、values（）和items( ) myTool = {&#39;first&#39;: &#39;python&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;, &#39;forth&#39;: &#39;perl&#39;} for k in myTool.keys(): print(k) first second third forth for v in myTool.values(): print(v) python R linux perl myTool.items() dict_items([(&#39;first&#39;, &#39;python&#39;), (&#39;second&#39;, &#39;R&#39;), (&#39;third&#39;, &#39;linux&#39;), (&#39;forth&#39;, &#39;perl&#39;)]) for k, v in myTool.items(): print(&#39;Key: &#39; + k + &#39; Value: &#39; + v) Key: first Value: python Key: second Value: R Key: third Value: linux Key: forth Value: perl #检查字典中是否存在键 &#39;first&#39; in myTool True &#39;hello&#39; in myTool False # get()，两个参数分别为“键”，如果没有该键，返回的值 myTool = {&#39;first&#39;: &#39;python&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;, &#39;forth&#39;: &#39;perl&#39;} myTool.get(&#39;first&#39;, 0) &#39;python&#39; myTool.get(&#39;hello&#39;, 0) 0 #不使用get()时,如果该键不存在，则报错 myTool[&#39;hello&#39;] --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-14-72a3aef6d23a&gt; in &lt;module&gt;() 1 #不使用get()时 ----&gt; 2 myTool[&#39;hello&#39;] KeyError: &#39;hello&#39; setdefault()如果没有该键，则添加 # 写循环实现 myTool = {&#39;first&#39;: &#39;python&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;, &#39;forth&#39;: &#39;perl&#39;} if &#39;fifth&#39; not in myTool: myTool[&#39;fifth&#39;] = &#39;C&#39; myTool {&#39;fifth&#39;: &#39;C&#39;, &#39;first&#39;: &#39;python&#39;, &#39;forth&#39;: &#39;perl&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;} # setdefault() myTool = {&#39;first&#39;: &#39;python&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;, &#39;forth&#39;: &#39;perl&#39;} myTool.setdefault(&#39;fifth&#39;, &#39;C&#39;) &#39;C&#39; myTool {&#39;fifth&#39;: &#39;C&#39;, &#39;first&#39;: &#39;python&#39;, &#39;forth&#39;: &#39;perl&#39;, &#39;second&#39;: &#39;R&#39;, &#39;third&#39;: &#39;linux&#39;} sequece = &#39;life is short, I use python&#39; count = {} for character in sequece: count.setdefault(character, 0) count[character] = count[character] + 1 print(count) {&#39;l&#39;: 1, &#39;i&#39;: 3, &#39;f&#39;: 1, &#39;e&#39;: 2, &#39; &#39;: 5, &#39;s&#39;: 3, &#39;h&#39;: 2, &#39;o&#39;: 2, &#39;r&#39;: 1, &#39;t&#39;: 2, &#39;,&#39;: 1, &#39;u&#39;: 1, &#39;p&#39;: 1, &#39;y&#39;: 1, &#39;n&#39;: 1} sequece = &#39;life is short, I use python&#39; count = {} for character in sequece: count[character] = count.get(character,0) + 1 print(count) {&#39;l&#39;: 1, &#39;i&#39;: 2, &#39;f&#39;: 1, &#39;e&#39;: 2, &#39; &#39;: 5, &#39;s&#39;: 3, &#39;h&#39;: 2, &#39;o&#39;: 2, &#39;r&#39;: 1, &#39;t&#39;: 2, &#39;,&#39;: 1, &#39;I&#39;: 1, &#39;u&#39;: 1, &#39;p&#39;: 1, &#39;y&#39;: 1, &#39;n&#39;: 1} # 简单序列计数 sequece = &#39;TCGAAATTCGGGCATGGAG&#39; count = {} for character in sequece: count.setdefault(character, 0) count[character] = count[character] + 1 for k, v in count.items(): print(k + &#39; &#39; + str(v)) T 4 C 3 G 7 A 5 1.18 字符串操作 #一个错误开始 &#39;This is Bob&#39;s book&#39; File &quot;&lt;ipython-input-26-9caaf6a74585&gt;&quot;, line 2 &#39;This is Bob&#39;s book&#39; ^ SyntaxError: invalid syntax 双引号 字符串可以使用双引号，双引号之间可以使用单引号 &quot;This is Bob&#39;s book&quot; &quot;This is Bob&#39;s book&quot; 转义符 \\n换行 \\'单引号 \\\"双引号 \\\\倒斜杠 \\t制表符 print(&quot;Life is short,\\n I use python&quot;) Life is short, I use python 原始字符串： 忽略转义符号 print(r&quot;Life is short,\\n I use python&quot;) Life is short,\\n I use python 三重引号多行字符串 print(&#39;&#39;&#39;Life is short,\\n I use python! do you like python yes&#39;&#39;&#39;) Life is short, I use python! do you like python yes 多行注释”“” ““” &quot;&quot;&quot; 简单序列计数 多行注释 &quot;&quot;&quot; sequece = &#39;TCGAAATTCGGGCATGGAG&#39; count = {} for character in sequece: count.setdefault(character, 0) count[character] = count[character] + 1 for k, v in count.items(): print(k + &#39; &#39; + str(v)) T 4 C 3 G 7 A 5 字符串切片 a = &quot;life is short, i use python&quot; a &#39;life is short, i use python&#39; a[1:5] &#39;ife &#39; a[-5:-3] &#39;yt&#39; a[-3:] &#39;hon&#39; &#39;python&#39; in a True 字符串方法 a = &#39;Hello world&#39; a.upper() &#39;HELLO WORLD&#39; b = &#39;NI HAO&#39; b.lower() &#39;ni hao&#39; b.isupper() True a.isupper() False # 简单介绍了验证码为什么不用区分大小写 feeling = input(&#39;How are you?\\n&#39;) if feeling.lower == &#39;great&#39;: print(&#39;I feel great too.&#39;) else: print(&#39;I hope you happy&#39;) How are you? Great I hope you happy is.X字符串方法 isalpha()是否只含字母 isalnum()是否只是字母或数字 isdecimal()是否只有数字 isspace()是否只有空格制表符换行 istitle()是否字符串为大写开头，后面均为小写字母 a = &#39;b1&#39; a.isalpha() False a = &#39;b c&#39; a.isalpha() False a = &#39;bc1&#39; a.isalnum() True a = &#39;1a&#39; a.isalnum() True while True: print(&#39;Enter your age:&#39;) age = input() if age.isdecimal(): break print(&#39;Please enter a number for your age.&#39;) while True: print(&#39;Select a new password (letters or numbers only):&#39;) password = input() if password.isalnum(): break print(&#39;Passwords can only have letters or numbers.&#39;) Enter your age: 2 Select a new password (letters or numbers only): + Passwords can only have letters or numbers. Select a new password (letters or numbers only): 2e startswith() 和 endswith() seq = &#39;&gt;0001\\nTCGATTACGG&#39; if seq.startswith(&#39;&gt;&#39;): print(seq) &gt;0001 TCGATTACGG join() 和 split() &#39;,&#39;.join([&#39;i&#39;, &#39;love&#39;, &#39;python&#39;]) &#39;i,love,python&#39; &#39;***&#39;.join([&#39;i&#39;, &#39;love&#39;, &#39;python&#39;]) &#39;i***love***python&#39; &quot;linux R perl C python&quot;.split() [&#39;linux&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;C&#39;, &#39;python&#39;] &#39;i***love***python&#39;.split(&#39;***&#39;) [&#39;i&#39;, &#39;love&#39;, &#39;python&#39;] 文本对齐rjust() ljust() center() &#39;hello&#39;.rjust(10) &#39; hello&#39; &#39;hello&#39;.rjust(20,&#39;*&#39;) &#39;***************hello&#39; &#39;hello&#39;.center(20,&#39;-&#39;) &#39;-------hello--------&#39; def printPicnic(itemsDict, leftWidth, rightWidth): print(&#39;PICNIC ITEMS&#39;.center(leftWidth + rightWidth, &#39;-&#39;)) for k, v in itemsDict.items(): print(k.ljust(leftWidth, &#39;.&#39;) + str(v).rjust(rightWidth)) picnicItems = {&#39;sandwiches&#39;: 4, &#39;apples&#39;: 12, &#39;cups&#39;: 4, &#39;cookies&#39;: 8000} printPicnic(picnicItems, 12, 5) printPicnic(picnicItems, 20, 6) ---PICNIC ITEMS-- sandwiches.. 4 apples...... 12 cups........ 4 cookies..... 8000 -------PICNIC ITEMS------- sandwiches.......... 4 apples.............. 12 cups................ 4 cookies............. 8000 strip(),rstrip(),lstrip() 删除空白字符 spam = &#39; hello &#39; spam &#39; hello &#39; spam.strip() &#39;hello&#39; spam.rstrip() &#39; hello&#39; spam.lstrip() &#39;hello &#39; a = &#39;Hello world, welcome to python world&#39; a.strip(&#39;d&#39;) &#39;Hello world, welcome to python worl&#39; FINISH "],["py3_ct.html", "2 Python 教程 2.1 背景介绍 2.2 Python程序事例 2.3 Python语法 2.4 输入输出 2.5 实战练习（一） 2.6 函数操作 2.7 模块 2.8 命令行参数 2.9 更多Python内容 2.10 Python画图 2.11 Reference", " 2 Python 教程 陈同 (chentong_biology@163.com) 欢迎来到Python的世界，本教程将带你遨游Python，领悟Python的魅力。本教程专注于帮助初学者，尤其是生物信息分析人员快速学会Python的常用功能和使用方式，因此只精选了部分Python的功能，请额外参考Python经典教程A byte of python和它的中文版 来更好的理解Python. 本文档的概念和文字描述参考了A byte of python(中文版)，特此感谢。 本教程在2017年12月25日更新到Python3版本。 This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 2.0 Generic License. B 站视频课程 （生信宝典知乎号、视频号同步更新）https://space.bilibili.com/362709786/lists/1988354?type=season 2.1 背景介绍 2.1.1 编程开篇 A：最近在看什么书？ B：编程。 A：沈从文的那本啊。 B：…… C：最近在学一门新语言，Python。 D：那是哪个国家的语言？ C：…… 2.1.2 为什么学习Python 语法简单 Python语言写作的程序就像自然语言构建的伪代码一样，“所见即所想”。读Python代码就像读最简单的英文短文一样，写Python代码比写英文文章都要简单，“所想即所写”。很多刚学习Python的朋友都觉得很不可思议，原来怎么想怎么写出来就对了。 功能强大 现在程序语言的发展已经很成熟，每一种程序语言都能实现其它程序语言的全部功能。因此就程序语言本身来讲，功能都相差不大。Python语言的功能强大在于其活跃的社区和强大的第三方模块支持，使其作为科学计算的能力越来越强。 可扩展性好 能与C完美的融合，加快运行速度。可用加速模块有Cython, PyPy, Pyrex, Psyco等. 2.1.3 Python常用包 科学计算 Numpy, SciPy (也是安装python包的拦路虎直到有了conda) 类比于R的数据框操作包 Pandas 可视化工具 Seaborn (配合pandas), matplotlib (类比MATLAB), plotly (交互式绘图), ggplot (类比ggplot2) 网站开发 web.py, Django, Flask 任务调度和流程管理 Airflow (pipeline首选) 机器学习 scikit-learn (经典), PyML, Tensorflow (谷歌释放), pylearn2, Orange (图形界面的机器学习包) 网页抓取 Beautiful Soup，requests, 可重复编程 Jupyter 正则表达式 re 2.1.4 怎么学习Python 编程就像拼乐高，需要我们知道每个组分的特征以便在需要时可以使用，也需要脑袋中有个蓝图知道每一步要做什么，二者结合，就可以拼出你想要的世界。 在我看来，学习编程是学以致用，学习方式是硬着头皮去读，去写。 多读经典书籍 首先从概念和理论上了解程序设计或Python程序设计，多读。书读百遍其义自见。 多做练习 任何练习题都可以，先易后难。如果能找到专业相关的，更好。 多读代码 多读优秀的代码，矫正自己的习惯和思维。 2.1.5 Python学习的几个阶段 （图例“编程信心与能力”：纵轴为信心值，横轴为能力水平，虚线从左至右依次分割出手牵手蜜月期、混沌悬崖、绝望沙漠、令人兴奋的上升期四个阶段，第5条虚线标志着工作准备就绪） 读文档是蜜月期，读读就过去，谁都会。 写程序是混沌悬崖，知道是这么回事，就是写不出来； 调程序是绝望沙漠，怎么看自己写的都对，就是编译器不开眼； 程序正确了就是兴奋期，万里长征迈出又一步。 2.1.6 如何安装Python Python社区有很多功能很好的包，但逐个安装需要解决繁杂的依赖关系。通常我会推荐安装已经做好的集成包，一劳永逸的解决后续问题。Anaconda是最优先推荐的分发包，集成了常用的数值计算、图形处理、可视化等工具包如IPython, matplotlib, numpy, scipy, 而且设定了更简单的安装Python模块的方法，可以节省大量的安装时间。 2.1.6.1 Python 常用包 科学计算 Numpy, SciPy (也是安装python包的拦路虎直到有了conda) 类比于R的数据框操作包 Pandas 可视化工具 Seaborn (配合pandas), matplotlib (类比MATLAB), plotly (交互式绘图), ggplot (类比ggplot2) 网站开发 web.py, Django, Flask 任务调度和流程管理 Airflow (pipeline首选) 机器学习 scikit-learn (经典), PyML, Tensorflow (谷歌释放), pylearn2, Orange (图形界面的机器学习包) 网页抓取 Beautiful Soup，requests, 可重复编程 Jupyter 正则表达式 re 2.1.7 如何运行Python命令和脚本 对于初学者，本手册推荐直接在Jupyter Notebook下学习Python命令和脚本。我们这套教程也是用Jupyter Notebook写作而成，里面的代码可以随时修改和运行，并能同时记录你的脚本和输出，符合现在流行的“可重复性计算”的概念。 Linux/Unix用户直接在终端(Terminal)进入你的目标文件夹cd /working_dir[回车]，然后在终端输入Jupyter notebook[回车]即可启动Jupyter notebook。 Windows用户可以新建一个Jupyter_notebook.bat文件(新建一个txt文件，写入内容后修改后缀为.bat。若不能修改后缀，请Google搜索“Window是如何显示文件扩展名”)，并写入以下内容（注意把前两行的盘符和路径替换为你的工作目录），双击即可运行。 D: cd PBR_training jupyter notebook pause Jupyter notebook启动后会打开默认的浏览器（需要在图形用户界面下工作），这时可以新建或打开相应路径下的ipynb文件。 对于LInux或Unix用户，直接在终端输入 python 然后回车即可打开交互式python解释器，如下图所示。在这个解释器了敲入任何合法的python语句即可执行。此外，所有的命令还可以存储到一个文件一起执行，如下图所示。我们有一个包含python程序的文件test.py，我们只要在终端输入python test.py并回车就可以运行这个文件。同时我们也可在终端通过输入chmod 755 test.py赋予程序test.py可执行权限，并在终端输入./test.py运行Python脚本。更多Linux下的高级使用和Linux命令使用请见教程Bash_training-chinese.ipynb。 对于Windows用户，可以通过“Windows键+R”调出“Run”窗口并输入“cmd”打开Windows命令解释器，输入python即可打开交互式python解释器。同时也可以双击安装后的软件的快捷方式打开图形界面的Python解释器，可以处理交互式命令和导入Python文件并执行。 对于交互式Python解释器，在使用结束后，通过键盘组合键Ctrl-d (Linux/Unix)或Ctrl-z (Windows)关闭。 2.1.8 使用什么编辑器写Python脚本 在你学成之后，可能主要操作都在服务器完成，而且日常工作一般会以脚本的形式解决。我个人推荐使用Vim来写作Python脚本。 Linux下vim的配置文件可从我的 github下载，Windows版可从我的百度云 下载。 2.2 Python程序事例 ## 假如我们有如下FASTA格式的文件，我们想把多行序列合并为一行，怎么做？ for line in open(&quot;data/test2.fa&quot;): print(line.strip()) &gt;NM_001011874 gene=Xkr4 CDS=151-2091 gcggcggcgggcgagcgggcgctggagtaggagctggggagcggcgcggccggggaaggaagccagggcg aggcgaggaggtggcgggaggaggagacagcagggacaggTGTCAGATAAAGGAGTGCTCTCCTCCGCTG CCGAGGCATCATGGCCGCTAAGTCAGACGGGAGGCTGAAGATGAAGAAGAGCAGCGACGTGGCGTTCACC CCGCTGCAGAACTCGGACAATTCGGGCTCTGTGCAAGGACTGGCTCCAGGCTTGCCGTCGGGGTCCGGAG &gt;NM_001195662 gene=Rp1 CDS=55-909 AAGCTCAGCCTTTGCTCAGATTCTCCTCTTGATGAAACAAAGGGATTTCTGCACATGCTTGAGAAATTGC AGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCA AGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGT GGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGC TGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACA CAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTG &gt;NM_011283 gene=Rp1 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC ACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACAC CTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATAT CACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGG GTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCC TGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGA GGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGG CGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATA TGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA &gt;NM_0112835 gene=Rp1 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC ACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACAC CTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATAT CACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGG GTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCC TGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGA GGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGG CGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATA TGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA aDict = {} for line in open(&#39;data/test2.fa&#39;): if line[0] == &#39;&gt;&#39;: key = line.strip() aDict[key] = [] else: aDict[key].append(line.strip()) ##------------------------------------------ for key, valueL in list(aDict.items()): print(key) print(&#39;&#39;.join(valueL)) &gt;NM_001011874 gene=Xkr4 CDS=151-2091 gcggcggcgggcgagcgggcgctggagtaggagctggggagcggcgcggccggggaaggaagccagggcgaggcgaggaggtggcgggaggaggagacagcagggacaggTGTCAGATAAAGGAGTGCTCTCCTCCGCTGCCGAGGCATCATGGCCGCTAAGTCAGACGGGAGGCTGAAGATGAAGAAGAGCAGCGACGTGGCGTTCACCCCGCTGCAGAACTCGGACAATTCGGGCTCTGTGCAAGGACTGGCTCCAGGCTTGCCGTCGGGGTCCGGAG &gt;NM_001195662 gene=Rp1 CDS=55-909 AAGCTCAGCCTTTGCTCAGATTCTCCTCTTGATGAAACAAAGGGATTTCTGCACATGCTTGAGAAATTGCAGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTG &gt;NM_011283 gene=Rp1 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCACACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGGCGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATATGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA &gt;NM_0112835 gene=Rp1 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCACACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGGCGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATATGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA 2.3 Python语法 2.3.1 层级缩进 合适的缩进。空白在Python中是很重要的，它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。这意味着同一层次的语句必须有相同的缩进。每一组这样的语句称为一个块。通常的缩进为4个空格, 在Jupyter Notebook中为一个Tab键。 从下面这两个例子可以看出错误的缩进类型和对应的提示。 “unexpected indent” 表示在不该出现空白的地方多了空白，并且指出问题出在第三行(line 3)。 “expected an indented block” 表示应该有缩进的地方未缩进，也指出了问题所在行。 “unindent does not match any outer indentation level” 表示缩进出现了不一致，问题通常会在指定行及其前面的行。 print(&quot;不合适的缩进会引发错误，b前不该有的缩进&quot;) a = &#39;No indent&#39; b = &#39;我前面有个空格……&#39; File &quot;&lt;ipython-input-2-ff110daefedf&gt;&quot;, line 3 b = &#39;我前面有个空格……&#39; ^ IndentationError: unexpected indent print(&quot;不合适的缩进，print是for的子语句，应该有缩进，却漏掉了&quot;) a = [1,2,3] for i in a: print &quot;我应该被缩进，我从属于for循环!!!\\n&quot; File &quot;&lt;ipython-input-3-84bbc644895e&gt;&quot;, line 5 print &quot;我应该被缩进，我从属于for循环!!!\\n&quot; ^ IndentationError: expected an indented block a = [1,2, 3] if a: for i in a: print(i) print(i + 1, &quot;为什么我的缩进跟其它行不一样呢，我的空格被谁吃了？&quot;) print(i + 1, &quot;为什么我的缩进跟其它行不一样呢，谁给了我个空格？&quot;) File &quot;&lt;tokenize&gt;&quot;, line 5 print(i + 1, ^ IndentationError: unindent does not match any outer indentation level 2.3.2 Python作为计算器的使用 Python中可以进行基本的数学运算，与小学中学过的一样，加减乘除取余数等，需要注意的是运算符的优先级。 2 + 2 4 2 + 3 +5 10 2 + 3 * 5 17 (2 + 3) * 5 25 ## 整除 23 // 7 3 ## 取余数 23 % 7 2 2.3.2.1 第一个小程序 print(&quot;Hello, Python!&quot;) Hello, Python! myname = input(&quot;Your name: &quot;) print(&quot;Hello&quot;, myname) Your name: CT Hello CT 2.3.3 变量、数据结构、流程控制 我们先看一个动图展示内存中变量的赋值、存储、值的改变和程序的运行。 常量，指固定的数字或字符串，如2, 2.9, \"Hello world\"等。 变量，存储了数字或字符串的事物称为变量，它可以被赋值或被修改。简单的可以理解为变量是一个盒子，你可以把任何东西放在里面，通过盒子的名字来取出盒子内的东西。 数值变量：存储了数的变量。 字符串变量：存储了字符串的变量。字符串变量的名字最好不为str，可以使用aStr。 列表 (list): list是处理一组有序项目的数据结构，即你可以在一个列表中存储一个 序列 的项目。假想你有一个购物列表，上面记载着你要买的东西，你就容易理解列表了。只不过在你的购物表上，可能每样东西都独自占有一行，而在Python中，你在每个项目之间用逗号分割。列表中的项目应该包括在方括号中，这样Python就知道你是在指明一个列表。一旦你创建了一个列表，你可以添加、删除或是搜索列表中的项目。由于你可以增加或删除项目，我们说列表是 可变的 数据类型，即这种类型是可以被改变的。列表变量的名字最好不为list，可以使用aList。 元祖 (tuple)：元组和列表十分类似，但是不可修改。元组通过圆括号中用逗号分割的项目定义。元组通常用在使语句或用户定义的函数能够安全地采用一组值的时候，即被使用的元组的值不会改变。元组变量的名字最好不为tuple，可以使用aTuple。 集合 (Set)：也与列表类似，但是元素不可重复。通常用来去除重复、求交集、并集等。而且集合的查询速度远远快于列表，可以用来提高运算速度。 字典 (dict): 字典类似于你通过联系人名字查找地址和联系人详细情况的地址簿，即，我们把键（名字）和值（详细情况）联系在一起。注意，键必须是唯一的，就像如果有两个人恰巧同名的话，你无法找到正确的信息。多个键可以指向同一个值。当一个键需要指向多个值时，这些值需要放在列表、元组或字典里面。注意，你只能使用不可变的对象（字符串，数字，元组）来作为字典的键，但是可以用不可变或可变的对象作为字典的值。键值对在字典中以这样的方式标记：d = {key1 : value1, key2 : value2 }。注意它们的键/值对用冒号分割，而各个对用逗号分割，所有这些都包括在花括号中。记住字典中的键/值对是没有顺序的。如果你想要一个特定的顺序，那么你应该在使用前自己对它们排序。列表变量的名字最好不为dict，可以使用aDict。 序列：列表、元组、字符串都是一种序列格式。同时还可以使用range来产生序列。序列的两个主要操作时索引操作和切片操作。 标示符 变量的名字被称为标示符。标识符对大小写敏感，第一个字符必须是字母表中的字母（大写或小写）或者一个下划线（_），其它部分额外包含数字。有效的标示符有: abc, _abc, a_b_2, __23等。无效的标示符有: 2a, 3b。 标示符最好不使用Python内置的关键字，如str, list, int, def, split, dict等。 标示符最好能言词达意，即展示变量的类型，又带有变量的实际含义。如line表示文件的一行，lineL表示存有从文件读入的每一行的列表。 控制流 if语句 if语句用来检验一个条件，如果条件为真，我们运行一块语句（称为 if-块），否则我们处理另外一块语句（称为 else-块）。else 从句是可选的。如果有多个条件，中间使用elif。 举个例子：“买五个包子，如果看到卖西瓜的，买一个”——最后程序猿买了一个包子” 买包子 = 5 if 看到卖西瓜的: 买包子 = 1 For语句 for..in是一个循环语句，它在一序列的对象上递归,即逐一使用队列中的每个项目。 While语句 只要在一个条件为真的情况下，while语句允许你重复执行一块语句。while语句是所谓 循环 语句的一个例子。while语句有一个可选的else从句。 break语句是用来 终止 循环语句的，即哪怕循环条件没有成为False或序列还没有被完全递归，也停止执行循环语句。 一个重要的注释是，如果你从for或while循环中 终止 ，任何对应的循环else块将不执行。 continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后 继续 进行下一轮循环。 逻辑运算符 and, or, not。 ## 变量名命名:为清晰表达，驼峰式，下划线式 LookLikeThis = 1 look_like_this = &#39;a&#39; 2.3.3.1 Python中的数据类型：整数（int）、浮点（float）和字符串（str） type(2) int type(2.5) float type(&quot;Hello, everyone&quot;) str type([1,2,3]) list ## 类型转换函数 str() int() float() str(2) &#39;2&#39; ## 字符和数字不同 42 != &quot;42&quot; True 42 == int(&quot;42&quot;) True ## This is my first python program！ myName = input(&quot;Hello, what is your name?&quot;) print(&#39;It is good to meet you,&#39; + myName) print(&#39;The length of your name is&#39;, str(len(myName))) myAge = input(&#39;What is your age?&#39;) print(&#39;You will be &#39; + str(int(myAge) + 1) + &#39; in a year.&#39;) Hello, what is your name?CT It is good to meet you,CT The length of your name is 2 What is your age?20 You will be 21 in a year. 2.3.3.2 逻辑值和比较操作 a = False a False b = True b True a = &quot;False&quot; a &#39;False&#39; 42 == 40 False 42 == &quot;42&quot; False 30 == 30 True ## 注意赋值(一个=)和比较(==)的区别 a = &#39;hello&#39; a == &#39;hello&#39; True 2.3.3.2.1 布尔操作符and, or, not 逻辑与 and：所有为真才为真 逻辑或 or：所有为假才为假 逻辑非 not: 真变假，假变真 (3 &gt; 2) and (5 &lt; 6) True (3 &lt; 2) or (5 &lt; 6) True not True False 2.3.3.3 控制流 if 条件（True or False） ： 代码块1 elif 条件 ： 代码块 else ： 代码块2 ##条件 name = input(&#39;Please enter a name and click Enter\\n&#39;) if name == &#39;Haha&#39;: print (&#39;hello Haha&#39;) else : print (&#39;You are not Haha&#39;) Please enter a name and click Enter CT You are not Haha 2.3.3.4 While循环 a = 0 while a &lt; 5: print(&#39;Hello, world&#39;) a = a + 1 Hello, world Hello, world Hello, world Hello, world Hello, world 2.3.3.5 数值变量操作 print(&quot;数值变量&quot;) a = 5 #注意等号两边的空格，为了易于辨识，操作符两侧最好有空格，数量不限 print(a) print() print(&quot;The type of a is&quot;, type(a)) ##print &quot;这是保留节目，通常判断变量的类型使用的不是type是isinstance.&quot; ##print &quot;a is an int, &quot;, isinstance(a,int) ## 再次赋值就是覆盖 a = 6 print(a) 数值变量 5 The type of a is &lt;class &#39;int&#39;&gt; 6 ## 判断 print(&quot;比较数值的大小&quot;) a = 5 ## 注意大于号两边的空格，为了易于辨识，操作符两侧最好有空格，数量不限 if a &gt; 4: print(&quot;a is larger than 4.&quot;) elif a == 4: print(&quot;a is equal to 4.&quot;) else: print(&quot;a is less than 4&quot;) 比较数值的大小 a is larger than 4. print(&quot;给定数值变量a和b的值，通过判断和重新赋值使得a的值小，b的值大&quot;) a = 5 b = 3 if a &gt; b: a,b = b,a ##------------------- print(a) print(b) 给定数值变量a和b的值，通过判断和重新赋值使得a的值小，b的值大 3 5 print(&#39;&#39;&#39;#数值运算, 符合传统的优先级，需要使用括号来改变优先级， 和小学学的数学一模一样！！&#39;&#39;&#39;) a = 5 b = 3 print(&quot;a + b =&quot;, a + b) print(&quot;a * b =&quot;, a * b) print(&quot;a / b =&quot;, a / b) # 1 print(&quot;2 * (a+b) =&quot;, 2 * (a + b)) print(&quot;取余数： a % b =&quot;, a % b) print(&quot;取余数是很好的判断循环的地方，因为每个固定的周期余数就会循环一次&quot;) #数值运算, 符合传统的优先级，需要使用括号来改变优先级， 和小学学的数学一模一样！！ a + b = 8 a * b = 15 a / b = 1.6666666666666667 2 * (a+b) = 16 取余数： a % b = 2 取余数是很好的判断循环的地方，因为每个固定的周期余数就会循环一次 3 / 0 --------------------------------------------------------------------------- ZeroDivisionError Traceback (most recent call last) &lt;ipython-input-17-2b706ee9dd8e&gt; in &lt;module&gt;() ----&gt; 1 3 / 0 ZeroDivisionError: division by zero 2.3.3.6 字符串变量操作 print(&quot;字符串变量&quot;) ## 注意引号的配对 a = &quot;Hello, welcome to Python&quot; ##a = 123 ##a = str(a) print(&quot;The string a is:&quot;, a) print() ## 占位符 print(&quot;The length of this string &lt;%s&gt; is %d&quot; % (a, len(a))) print() print(&quot;The type of a is&quot;, type(a)) 字符串变量 The string a is: Hello, welcome to Python The length of this string &lt;Hello, welcome to Python&gt; is 24 The type of a is &lt;class &#39;str&#39;&gt; a = &quot;大事赖独断而不赖众谋&quot; print(&quot;The string a is:&quot;, a) print() ## len函数：获得字符串长度 print(&quot;The length of this string &lt;%s&gt; is %d&quot; % (a, len(a))) print() The string a is: 大事赖独断而不赖众谋 The length of this string &lt;大事赖独断而不赖众谋&gt; is 10 a = &quot;Hello, welcome to Python&quot; print(&quot;取出字符串的第一个字符、最后一个字符、中间部分字符&quot;) print(&quot;The first character of a is %s\\n&quot; % a[0]) print(&quot;The first five characters of a are %s\\n&quot; % a[0:5]) print(&quot;The last character of a is %s\\n&quot; % a[-1]) print(&quot;The last two characters of a are %s\\n&quot; % a[-2:]) print(&quot;The last character of a is %s\\n&quot; % a[len(a) - 1]) print(&quot;\\n这部分很重要啊，字符串的索引和切片操作是及其常用的。&quot;) 取出字符串的第一个字符、最后一个字符、中间部分字符 The first character of a is H The first five characters of a are Hello The last character of a is n The last two characters of a are on The last character of a is n 这部分很重要啊，字符串的索引和切片操作是及其常用的。 a = &quot;oaoaoaoa&quot; print(&quot;遍历字符串&quot;) for i in a: print(i) print() print(&quot;The index of first &lt;o&gt; is: &quot;,a.find(&#39;o&#39;)) print(&quot;The index of first &lt;c&gt; is: &quot;,a.find(&#39;c&#39;)) print(&quot;输出符合特定要求的字符的位置&quot;) print() pos = 0 for i in a: pos += 1 if i == &#39;o&#39;: print(pos) #------------------- ##----------------------- print(&#39;&#39;&#39;\\n知道吗？不经意间我们写出了Python的 一个内置的标准函数find或者index,而且功能还更强大&#39;&#39;&#39;) print(&#39;&#39;&#39;\\n自己尝试实现程序语言内建的函数是学习程序语言 的很好方法。&#39;&#39;&#39;) 遍历字符串 o a o a o a o a The index of first &lt;o&gt; is: 0 The index of first &lt;c&gt; is: -1 输出符合特定要求的字符的位置 1 3 5 7 知道吗？不经意间我们写出了Python的 一个内置的标准函数find或者index,而且功能还更强大 自己尝试实现程序语言内建的函数是学习程序语言 的很好方法。 print(&quot;我们看看用内置函数如何找到所有 o 的位置\\n&quot;) a = &quot;oaoaoaoa&quot; print(&quot;内置函数find只能确定最先出现的 o 的位置&quot;) pos = a.find(&#39;o&#39;) print(&quot;因此，我们要在发现 o 之后，截取其后的字符串，再执行find操作&quot;) while 1: print(pos + 1) new = a[pos + 1:].find(&#39;o&#39;) if new == -1: break pos = new + pos + 1 ## help(str) 我们看看用内置函数如何找到所有 o 的位置 内置函数find只能确定最先出现的 o 的位置 因此，我们要在发现 o 之后，截取其后的字符串，再执行find操作 1 3 5 7 print() print(&quot;利用split分割字符串\\n&quot;) str1 = &quot;a b c d e f g&quot; strL = str1.split(&#39; &#39;) print(strL) print(&quot;\\n使用split命令就可以把字符串分成列表了，想取用哪一列都随便你了。&quot;) ## 使用下面的命令查看可以对字符串进行的操作 ## help(str) 利用split分割字符串 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] 使用split命令就可以把字符串分成列表了，想取用哪一列都随便你了。 print(&quot;字符串的连接\\n&quot;) a = &quot;Hello&quot; b = &quot;Python&quot; c = a + &#39;, &#39; + b print(c) print(&quot;\\n原来字符串相加就可以连起来啊！\\n&quot;) print(&#39;&#39;&#39;注意，这不是连接字符串最好的方式。 考虑到字符串是不可修改的，每次连接操作都是新开辟一个内存空间， 把字符串存到里面，这样的连接操作执行几十万次会很影响运行速度。&#39;&#39;&#39;) 字符串的连接 Hello, Python 原来字符串相加就可以连起来啊！ 注意，这不是连接字符串最好的方式。 考虑到字符串是不可修改的，每次连接操作都是新开辟一个内存空间， 把字符串存到里面，这样的连接操作执行几十万次会很影响运行速度。 关于字符串链接为什么不推荐使用 +，文章为啥我的Python这么慢 (一)给出了一个很好的演示例子。 print(&#39;&#39;&#39;去除字符串中特定的字符。通常我们在文件中读取的一行都包含换行符， linux下为\\\\n \\n&#39;&#39;&#39;) # \\\\转义字符 a = &quot;oneline\\n&quot; print(&quot;Currently, the string &lt;a&gt; is **&quot;, a, &quot;**. \\ \\n The length of string &lt;a&gt; is **&quot;, len(a), &quot;**. \\ \\n 我为什么换到下一行了？\\n&quot;) a = a.strip() print(&quot;Currently, the string &lt;a&gt; is **&quot;, a, &quot;**. \\ \\n The length of string &lt;a&gt; is **&quot;, len(a), &quot;**. \\ \\n 删掉了换行符后，少了个字符，而且没换行！\\n&quot;) a = a.strip(&#39;o&#39;) print(&quot;Currently, the string &lt;a&gt; is **&quot;, a, &quot;**. \\ \\n The length of string &lt;a&gt; is **&quot;, len(a), &quot;**. \\ 又少了个字符！！\\n&quot;) a = a.strip(&#39;one&#39;) print(&quot;Currently, the string &lt;a&gt; is **&quot;, a, &quot;**. \\ \\n The length of string &lt;a&gt; is **&quot;, len(a), &quot;**. \\ 又少字符了！！\\n&quot;) 去除字符串中特定的字符。通常我们在文件中读取的一行都包含换行符， linux下为\\n Currently, the string &lt;a&gt; is ** oneline **. The length of string &lt;a&gt; is ** 8 **. 我为什么换到下一行了？ Currently, the string &lt;a&gt; is ** oneline **. The length of string &lt;a&gt; is ** 7 **. 删掉了换行符后，少了个字符，而且没换行！ Currently, the string &lt;a&gt; is ** neline **. The length of string &lt;a&gt; is ** 6 **. 又少了个字符！！ Currently, the string &lt;a&gt; is ** li **. The length of string &lt;a&gt; is ** 2 **. 又少字符了！！ print(&quot;字符串的替换\\n&quot;) a = &quot;Hello, Python&quot; b = a.replace(&quot;Hello&quot;, &quot;Welcome&quot;) print(&quot;原始字符串是:&quot;, a) print() print(&quot;替换后的字符串是:&quot;, b) print() c = a.replace(&quot;o&quot;, &quot;O&quot;) print(c) print(&quot;所有的o都被替换了！\\n&quot;) print(&quot;如果我只替换第一个o怎么办呢？\\n&quot;) c = a.replace(&quot;o&quot;, &quot;O&quot;, 1) print(c) 字符串的替换 原始字符串是: Hello, Python 替换后的字符串是: Welcome, Python HellO, PythOn 所有的o都被替换了！ 如果我只替换第一个o怎么办呢？ HellO, Python ## 中文替换也可以 a = &quot;忙处事为，常向闲中先检点，过举自稀；动时念想，预从静里密操持，非心自息。&quot; print(a.replace(&#39;；&#39;, &#39;\\n&#39;)) 忙处事为，常向闲中先检点，过举自稀 动时念想，预从静里密操持，非心自息。 print(&quot;字符串帮助，查看字符串可用方法&quot;) help(str) print(&quot;大小写判断和转换&quot;) a = &#39;Sdsdsd&#39; print(&quot;All elements in &lt;%s&gt; is lowercase: %s&quot; % (a, a.islower())) print(&quot;Transfer all elments in &lt;%s&gt; to lowerse &lt;%s&gt;&quot; % (a, a.lower())) print(&quot;Transfer all elments in &lt;%s&gt; to upperse &lt;%s&gt;&quot; % (a, a.upper())) 大小写判断和转换 All elements in &lt;Sdsdsd&gt; is lowercase: False Transfer all elments in &lt;Sdsdsd&gt; to lowerse &lt;sdsdsd&gt; Transfer all elments in &lt;Sdsdsd&gt; to upperse &lt;SDSDSD&gt; print(&quot;这个是个保留节目，有兴趣的看，无兴趣的跳过不影响学习&quot;) print(&#39;&#39;&#39;字符串是不可修改的， 同一个变量名字赋不同的只实际是产生了多个不同的变量。 不同的变量名字赋同样的值，用于比较时相等，但引用不同的区域&#39;&#39;&#39;) b = &quot;123456&quot; ## print b print(&quot;The memory index of b is&quot;, id(b)) for i in range(1, 15, 2): b = b + &#39;123456&#39; # print b print(&quot;The memory index of b is&quot;, id(b)) 这个是个保留节目，有兴趣的看，无兴趣的跳过不影响学习 字符串是不可修改的， 同一个变量名字赋不同的只实际是产生了多个不同的变量。 不同的变量名字赋同样的值，用于比较时相等，但引用不同的区域 The memory index of b is 139844870936200 The memory index of b is 139844868463728 The memory index of b is 139844870954056 The memory index of b is 139844863857088 The memory index of b is 139844863857088 The memory index of b is 139845221506544 The memory index of b is 139844869671408 The memory index of b is 139844868660840 print(&quot;字符串转数组&quot;) print() str1 = &quot;ACTG&quot; print(list(str1)) a = list(str1) print() print(&quot;字符串转数组之后就可以逆序了，得到其反向序列&quot;) print() a.reverse() print(&#39;&#39;.join(a)) 字符串转数组 [&#39;A&#39;, &#39;C&#39;, &#39;T&#39;, &#39;G&#39;] 字符串转数组之后就可以逆序了，得到其反向序列 GTCA print(&quot;数字字符串转数值&quot;) a = &#39;123&#39; print(a + &#39;1&#39;, int(a) + 1) a = &#39;123.5&#39; print() ## print a + 1 print(float(a) + 1) print(&#39;&#39;&#39;从文件或命令行参数中取出的数字都是字符串形式出现， 做四则运算时要先用int 或 float转换。&#39;&#39;&#39;) 数字字符串转数值 1231 124 124.5 从文件或命令行参数中取出的数字都是字符串形式出现， 做四则运算时要先用int 或 float转换。 print(&quot;字符串倍增&quot;) a = &quot;Haha &quot; a * 4 字符串倍增 &#39;Haha Haha Haha Haha &#39; a * 0 &#39;&#39; ## 倍增不可以是小数 a * 3.1 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-21-c65dd4dac397&gt; in &lt;module&gt;() ----&gt; 1 a * 3.1 TypeError: can&#39;t multiply sequence by non-int of type &#39;float&#39; 2.3.3.7 break和continue ## 模拟登陆账号, 用户名 Bob, 密码fish while True: name = input(&#39;Who are you?\\n&gt; &#39;) if name != &#39;Bob&#39;: continue # 将程序跳转到开头 password = input(&#39;Hello, Bob. What is your password? (password: fish)\\n&gt; &#39;) if password == &#39;fish&#39;: break # 跳出所在循环或最内层循环 print(&#39;Acess granted!&#39;) Who are you? &gt; CT Who are you? &gt; Bob Hello, Bob. What is your password? (password: fish) &gt; sdsds Who are you? &gt; Bob Hello, Bob. What is your password? (password: fish) &gt; fish Acess granted! 2.3.3.8 for range (获取一系列数) ## 如果只给一个参数，则是从0-给定参数(不包括)，步长为1 for i in range(4): print(i) 0 1 2 3 ## 1: start; 10: end (不包括); 2: step for i in range(1,10,2): print(i) 1 3 5 7 9 ## 步长也可以为负值，从大到小 for i in range(10,1,-2): print(i) 10 8 6 4 2 高斯计算1-100的加和。 ## 高斯的1+2+3+...+100=? total = 0 ## 参数是101，为什么呢？ for i in range(1,101): total = total + i print(total) 5050 ## 高斯优化后的 end = 100 sum_all = int((1+end) * end / 2) ##else: ## sum_all = end * (end -1 ) / 2 + end print(sum_all) 5050 脑筋急转弯，题目如下: 现有100元钱，需要买100个物品，其中铅笔盒单价5元，笔单价3元，橡皮单价0.5元，怎么组合可以把100元花完，同时三种物品的个数和为100，请用编程解决。 ## 纯暴力解法 for x in range(0, 101): for y in range(0, 101): for z in range(0, 101): if x + y + z == 100 and 5 * x + 3 * y + 0.5 * z == 100: print(x, y, z) 0 20 80 5 11 84 10 2 88 ## 优化后的暴力解法 ## 限定box和pen的最大数目，也就是全部钱只买他们，最多能买多少个？ max_box = int(100 / 5) + 1 max_pen = int(100 / 3) + 1 for box_num in range(max_box): # 需要买的物品总数是固定的， for pen_num in range(max_pen - box_num): eraser_num = 100 - box_num - pen_num if 5 * box_num + 3 * pen_num + 0.5 * eraser_num == 100: print((box_num, pen_num, eraser_num)) (0, 20, 80) (5, 11, 84) (10, 2, 88) 2.3.3.9 列表操作 print(&quot;#构建一个数组&quot;) aList = [1, 2, 3, 4, 5] print(aList) print(&quot;\\n数组可以用下标或区域进行索引\\n&quot;) print(&quot;The first element is %d.&quot; % aList[0]) print() print(&quot;The last element is %d.&quot; % aList[-1]) print() print(&quot;The first two elements are&quot;, aList[:2]) print(&quot;\\n数组索引和切片操作与字符串是一样一样的，而且都很重要。&quot;) #构建一个数组 [1, 2, 3, 4, 5] 数组可以用下标或区域进行索引 The first element is 1. The last element is 5. The first two elements are [1, 2] 数组索引和切片操作与字符串是一样一样的，而且都很重要。 aList = [] print(&quot;#append: 向数组中增加元素&quot;) aList.append(6) print(aList) print(&quot;\\n#extend: 向数组中增加一个数组&quot;) print() bList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] aList.extend(bList) print(aList) aList + bList #append: 向数组中增加元素 [6] #extend: 向数组中增加一个数组 [6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] [6, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] aList = [1, 2, 3, 4, 3, 5] print(&quot;在数组中删除元素&quot;) aList.remove(3) # 只删除第一个匹配的 3 print() print(aList) aList.pop(3) # 移除元素的下标为3的字符 print() print(aList) print(&#39;&#39;&#39;\\npop和remove是不一样的，remove是移除等于给定值的元素， pop是移除给定位置的元素\\n&#39;&#39;&#39;) 在数组中删除元素 [1, 2, 4, 3, 5] [1, 2, 4, 5] pop和remove是不一样的，remove是移除等于给定值的元素， pop是移除给定位置的元素 aList = [1, 2, 3, 4, 5] print(&quot;#遍历数组的每个元素&quot;) print() for ele in aList: print(ele) print(&quot;\\n#输出数组，并输出大于3的元素&quot;) print() for ele in aList: if ele &gt; 3: print(ele) #遍历数组的每个元素 1 2 3 4 5 #输出数组中大于3的元素 4 5 aList = [i for i in range(30)] aList aList = [i for i in range(30) if i % 2 ==0] aList [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28] aList = [i for i in range(30)] print(&quot;#输出数组中大于3,且小于10的元素&quot;) print() for ele in aList: if ele &gt; 3 and ele &lt; 10: # 逻辑与，当两个条件都符合时才输出 print(ele) #输出数组中大于3,且小于10的元素 4 5 6 7 8 9 aList = [i for i in range(30)] print(&quot;#输出数组中大于25,或小于5的元素&quot;) print() for ele in aList: if ele &gt; 25 or ele &lt; 5: # 逻辑或，当两个条件满足一个时就输出 print(ele) #输出数组中大于25,或小于5的元素 0 1 2 3 4 26 27 28 29 aList = [i for i in range(30)] print(&quot;#输出数组中不大于3的元素&quot;) print() for ele in aList: # 逻辑非，当不符合给定条件时才输出。 # 对于这个例子就是ele不大于3时才输出，相当于 if ele &lt;= 3: if not ele &gt; 3: print(ele) #输出数组中大于3,且小于10的元素 0 1 2 3 aList = [1, 2, 3, 4, 5] print(&#39;\\t&#39;.join(aList)) #wrong --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-33-193d4492669b&gt; in &lt;module&gt;() 1 aList = [1, 2, 3, 4, 5] ----&gt; 2 print(&#39;\\t&#39;.join(aList)) #wrong TypeError: sequence item 0: expected str instance, int found print(&quot;连接数组的每个元素（每个元素必须为字符串）&quot;) aList = [1, 2, 3, 4, 5] ## print &#39;\\t&#39;.join(aList) #wrong print(aList) aList = [str(i) for i in aList] print(aList) print(&#39;\\t&#39;.join(aList)) print(&#39;:&#39;.join(aList)) print(&#39;&#39;.join(aList)) print(&#39;&#39;&#39;\\n先把字符串存到列表，再使用join连接， 是最合适的连接大量字符串的方式&#39;&#39;&#39;) 连接数组的每个元素（每个元素必须为字符串） [1, 2, 3, 4, 5] [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;] 1 2 3 4 5 1:2:3:4:5 12345 先把字符串存到列表，再使用join连接， 是最合适的连接大量字符串的方式 aList = [1, 2, 3, 4, 5] print(&quot;数组反序&quot;) aList.reverse() print(aList) print(&quot;数组元素排序&quot;) aList.sort() print(aList) ## print &quot;lambda排序，保留节目&quot; ##aList.sort(key=lambda x: x*(-1)) ## print aList 数组反序 [5, 4, 3, 2, 1] 数组元素排序 [1, 2, 3, 4, 5] aList = [[1,2], [3,4], [2,1]] aList.sort() aList [[1, 2], [2, 1], [3, 4]] aList.sort(key=lambda x: x[1]) aList [[2, 1], [1, 2], [3, 4]] 2.3.3.10 集合操作 print(&quot;构建一个集合&quot;) aSet = set([]) aSet = set([1, 2, 3]) print(aSet) print(&quot;增加一个元素&quot;) aSet.add(4) print(aSet) aSet.add(3) print(aSet) 构建一个集合 {1, 2, 3} 增加一个元素 {1, 2, 3, 4} {1, 2, 3, 4} print(&quot;采用转换为集合去除列表中的重复元素&quot;) aList = [1, 2, 1, 3, 1, 5, 2, 4, 3, 3, 6] print(aList) print(set(aList)) print(list(set(aList))) 采用转换为集合去除列表中的重复元素 [1, 2, 1, 3, 1, 5, 2, 4, 3, 3, 6] {1, 2, 3, 4, 5, 6} [1, 2, 3, 4, 5, 6] 2.3.3.11 Range使用 print(&quot;\\n使用range，产生一系列的字符串\\n&quot;) for i in range(16): if i % 4 == 0: print(i) print(&quot;\\n通过指定步长产生4的倍数的数\\n&quot;) for i in range(0, 16, 4): print(i) 使用range，产生一系列的字符串 0 4 8 12 通过指定步长产生4的倍数的数 0 4 8 12 2.3.3.12 字典操作 print(&quot;#构建一个字典&quot;) aDict = {} aDict = {1: 2, 3: 4, &#39;a&#39;: [&#39;b&#39;,&#39;d&#39;], &#39;d&#39;: &#39;c&#39;, &#39;e&#39;: {1:2}} print(&quot;打印字典&quot;) print(aDict) print(&quot;向字典中添加键值对&quot;) aDict[5] = 6 aDict[&#39;e&#39;] = &#39;f&#39; print(aDict) #构建一个字典 打印字典 {1: 2, 3: 4, &#39;a&#39;: [&#39;b&#39;, &#39;d&#39;], &#39;d&#39;: &#39;c&#39;, &#39;e&#39;: {1: 2}} 向字典中添加键值对 {1: 2, 3: 4, &#39;a&#39;: [&#39;b&#39;, &#39;d&#39;], &#39;d&#39;: &#39;c&#39;, &#39;e&#39;: &#39;f&#39;, 5: 6} print() aDict = {1: 2, 3: 4, &#39;a&#39;: &#39;b&#39;, &#39;d&#39;: &#39;c&#39;} print(&quot;输出字典的键值对(key-value)&quot;) for key, value in list(aDict.items()): print(key, value) 输出字典的键值对(key-value) 1 2 3 4 a b d c print(&quot;有序输出字典的键值对(key-value)&quot;) aDict = {&#39;1&#39;: 2, &#39;3&#39;: 4, &#39;a&#39;: &#39;b&#39;, &#39;d&#39;: &#39;c&#39;} keyL = list(aDict.keys()) print(keyL) ## Python3中不支持int型和str型的比较 ## 需要先都转换为str型 ## keyL = [str(i) for i in keyL] keyL.sort() print(keyL) for key in keyL: print(key, aDict[key]) 有序输出字典的键值对(key-value) [&#39;1&#39;, &#39;3&#39;, &#39;a&#39;, &#39;d&#39;] [&#39;1&#39;, &#39;3&#39;, &#39;a&#39;, &#39;d&#39;] 1 2 3 4 a b d c print(&quot;字典的value可以是一个列表&quot;) a = &#39;key&#39; b = &#39;key2&#39; aDict = {} print(aDict) aDict[a] = [] print(aDict) aDict[a].append(1) aDict[a].append(2) print(aDict) aDict[b] = [3, 4, 5] print() for key, subL in list(aDict.items()): print(key) for item in subL: print(&quot;\\t%s&quot; % item) print(&quot;这个在存取读入的文件时会很有用的，下面的实战练习会用到这个。&quot;) 字典的value可以是一个列表 {} {&#39;key&#39;: []} {&#39;key&#39;: [1, 2]} key 1 2 key2 3 4 5 这个在存取读入的文件时会很有用的，下面的实战练习会用到这个。 字典可以用中文做Key，中文做value。 aDict = {&#39;菜根谭&#39;: &#39;事理因人言而悟者，有悟还有迷，总不如自悟之了了；意兴从外境而得者，有得还有失，总不如自得之休休。&#39;} print(aDict[&#39;菜根谭&#39;]) 事理因人言而悟者，有悟还有迷，总不如自悟之了了；意兴从外境而得者，有得还有失，总不如自得之休休。 print(&quot;字典的value也可以是字典&quot;) a = &#39;key&#39; b = &#39;key2&#39; aDict = {} print(aDict) aDict[a] = {} print(aDict) aDict[a][&#39;subkey&#39;] = &#39;subvalue&#39; print(aDict) aDict[b] = {1: 2, 3: 4} ##aDict[(a,b)] = 2 ##aDict[&#39;a&#39;] = 2 ##aDict[&#39;b&#39;] = 2 print() for key, subD in list(aDict.items()): print(key) for subKey, subV in list(subD.items()): print(&quot;\\t%s\\t%s&quot; % (subKey, subV)) print(&quot;\\n这个在存取读入的文件时会很有用的，下面的实战练习会用到这个。&quot;) 字典的value也可以是字典 {} {&#39;key&#39;: {}} {&#39;key&#39;: {&#39;subkey&#39;: &#39;subvalue&#39;}} key subkey subvalue key2 1 2 3 4 这个在存取读入的文件时会很有用的，下面的实战练习会用到这个。 2.4 输入输出 2.4.1 交互式输入输出 在很多时候，你会想要让你的程序与用户（可能是你自己）交互。你会从用户那里得到输入，然后打印一些结果。我们可以分别使用raw_input和print语句来完成这些功能。 a = input(&quot;Please input a string and type enter\\n&gt; &quot;) print(&quot;The string you typed in is: &quot;, a) Please input a string &gt; sheng xin bao dian The string you typed in is: sheng xin bao dian print(&quot;这是一个保留例子，仅供玩耍\\n&quot;) lucky_num = 5 c = 0 while True: b = int(input(&quot;Please input a number to check if you are \\ lucky enough to guess right: \\n&quot;)) if b == lucky_num: print(&quot;\\nYour are so smart!!! ^_^ ^_^&quot;) #---------------------------------------------------- #-------------------------------------------------------- else: print(&quot;\\nSorry, but you are not right. %&gt;_&lt;%&quot;) while 1: c = input(&quot;Do you want to try again? [Y/N] \\n&quot;) if c == &#39;Y&#39;: try_again = 1 break elif c == &#39;N&#39;: try_again = 0 break else: print(&quot;I can not understand you, please check your input. \\n&quot;) continue #---------------------------------------------------- if try_again: print(&quot;\\nHere comes another run. Enjoy!\\n&quot;) continue else: print(&quot;\\nBye-bye\\n&quot;) break 这是一个保留例子，仅供玩耍 Please input a number to check if you are lucky enough to guess right: 4 Sorry, but you are not right. %&gt;_&lt;% Do you want to try again? [Y/N] Y Here comes another run. Enjoy! Please input a number to check if you are lucky enough to guess right: 3 Sorry, but you are not right. %&gt;_&lt;% Do you want to try again? [Y/N] N Bye-bye 2.4.2 文件读写 文件读写是最常见的输入和输出操作。你可以实用file或open来实现。 2.4.2.1 文件路径 读写文件时若没有指定文件路径，默认为当前目录。因此需要知道当前所在的目录，然后判断要读取的文件是否在当前目录。 import os os.getcwd() ## os.chdir(&quot;path&quot;) &#39;/MPATHB/ct/ipython/notebook&#39; print(&quot;新建一个文件&quot;) context = &#39;&#39;&#39;The best way to learn python contains two steps: 1. Rember basic things mentionded here masterly. 2. Practise with real demands. &#39;&#39;&#39; print(&quot;以写入模式(w)打开一个文件并命名为(Test_file.txt)&quot;) fh = open(&quot;Test_file.txt&quot;, &quot;w&quot;) print(context, file=fh) ## fh.write(context) fh.close() # 文件操作完成后必须关闭文件句柄 新建一个文件 以写入模式(w)打开一个文件并命名为(Test_file.txt) with open(&quot;Test_file.txt&quot;, &quot;w&quot;) as fh: print(context, file=fh) print(&quot;以只读模式(r)读入一个名为(Test_file.txt)的文件&quot;) print() for line in open(&quot;Test_file.txt&quot;): print(line) 以只读模式(r)读入一个名为(Test_file.txt)的文件 The best way to learn python contains two steps: 1. Rember basic things mentionded here masterly. 2. Practise with real demands. 仔细看看上面的输出结果，看上去很空，空行比较多。 print(&#39;&#39;&#39;避免中间空行的输出。 从文件中读取的每一行都带有一个换行符， 而Python的print默认会在输出结束时加上换行符， 因此打印一行会空出一行。为了解决这个问题，有下面两套方案。&#39;&#39;&#39;) print(&quot;end=&#39;&#39;&quot;) print() for line in open(&quot;Test_file.txt&quot;): print(line, end=&#39;&#39;) print() print(&quot;去掉每行自身的换行符&quot;) for line in open(&quot;Test_file.txt&quot;): print(line.strip()) 避免中间空行的输出。 从文件中读取的每一行都带有一个换行符， 而Python的print默认会在输出结束时加上换行符， 因此打印一行会空出一行。为了解决这个问题，有下面两套方案。 end=&#39;&#39; The best way to learn python contains two steps: 1. Rember basic things mentionded here masterly. 2. Practise with real demands. 去掉每行自身的换行符 The best way to learn python contains two steps: 1. Rember basic things mentionded here masterly. 2. Practise with real demands. 2.5 实战练习（一） 2.5.1 背景知识 1. FASTA文件格式 &gt;seq_name_1 sequence1 &gt;seq_name_2 sequence2 2. FASTQ文件格式 @HWI-ST1223:80:D1FMTACXX:2:1101:1243:2213 1:N:0:AGTCAA TCTGTGTAGCCNTGGCTGTCCTGGAACTCACTTTGTAGACCAGGCTGGCATGCA BCCFFFFFFHH#4AFHIJJJJJJJJJJJJJJJJJIJIJJJJJGHIJJJJJJJJJ 2.5.2 作业 (一) 给定FASTA格式的文件(test1.fa 和 test2.fa)，写一个程序 cat.py 读入文件，并输出到屏幕 用到的知识点 open(file) for .. in loop print the amazng , or strip() function 给定FASTQ格式的文件(test1.fq), 写一个程序 cat.py 读入文件，并输出到屏幕 用到的知识点 同上 写程序 splitName.py, 读入test2.fa, 并取原始序列名字第一个空格前的名字为处理后的序列名字，输出到屏幕 用到的知识点 split 字符串的索引 输出格式为： &gt;NM_001011874 gcggcggcgggcgagcgggcgctggagtaggagctg....... 写程序 formatFasta.py, 读入test2.fa，把每条FASTA序列连成一行然后输出 用到的知识点 join strip 输出格式为: &gt;NM_001011874 gcggcggcgggc......TCCGCTG......GCGTTCACC......CGGGGTCCGGAG 写程序 formatFasta-2.py, 读入test2.fa，把每条FASTA序列分割成80个字母一行的序列 用到的知识点 字符串切片操作 range 输出格式为 &gt;NM_001011874 gcggcggcgc.(60个字母).TCCGCTGACG #(每行80个字母) acgtgctacg.(60个字母).GCGTTCACCC ACGTACGATG(最后一行可不足80个字母) 写程序 sortFasta.py, 读入test2.fa, 并取原始序列名字第一个空格前的名字为处理后的序列名字，排序后输出 用到的知识点 sort dict aDict[key] = [] aDict[key].append(value) 提取给定名字的序列 写程序 grepFasta.py, 提取fasta.name中名字对应的test2.fa的序列，并输出到屏幕。 写程序 grepFastq.py, 提取fastq.name中名字对应的test1.fq的序列，并输出到文件。 用到的知识点 print &gt;&gt;fh, or fh.write() 取模运算，4 % 2 == 0 写程序 screenResult.py, 筛选test.expr中foldChange大于2的基因并且padj小于0.05的基，可以输出整行或只输出基因名字 用到的知识点 逻辑与操作符 and 文件中读取的内容都为字符串，需要用int转换为整数，float转换为浮点数 写程序 transferMultipleColumToMatrix.py 将文件(multipleColExpr.txt)中基因在多个组织中的表达数据转换为矩阵形式 用到的知识点 aDict[‘key’] = {} aDict[‘key’][‘key2’] = value if key not in aDict aDict = {‘ENSG00000000003’: {“A-431”: 21.3, “A-549”, 32.5,…},“ENSG00000000003”:{},} 输入格式(只需要前3列就可以) Gene Sample Value Unit Abundance ENSG00000000003 A-431 21.3 FPKM Medium ENSG00000000003 A-549 32.5 FPKM Medium ENSG00000000003 AN3-CA 38.2 FPKM Medium ENSG00000000003 BEWO 31.4 FPKM Medium ENSG00000000003 CACO-2 63.9 FPKM High ENSG00000000005 A-431 0.0 FPKM Not detected ENSG00000000005 A-549 0.0 FPKM Not detected ENSG00000000005 AN3-CA 0.0 FPKM Not detected ENSG00000000005 BEWO 0.0 FPKM Not detected ENSG00000000005 CACO-2 0.0 FPKM Not detected 输出格式 Name A-431 A-549 AN3-CA BEWO CACO-2 ENSG00000000460 25.2 14.2 10.6 24.4 14.2 ENSG00000000938 0.0 0.0 0.0 0.0 0.0 ENSG00000001084 19.1 155.1 24.4 12.6 23.5 ENSG00000000457 2.8 3.4 3.8 5.8 2.9 写程序 reverseComplementary.py计算序列 ACGTACGTACGTCACGTCAGCTAGAC的反向互补序列 用到的知识点 reverse list(seq) 写程序 collapsemiRNAreads.py转换smRNA-Seq的测序数据 输入文件格式(mir.collapse, tab-分割的两列文件，第一列为序列，第二列为序列被测到的次数) ID_REF VALUE ACTGCCCTAAGTGCTCCTTCTGGC 2 ATAAGGTGCATCTAGTGCAGATA 25 TGAGGTAGTAGTTTGTGCTGTTT 100 TCCTACGAGTTGCATGGATTC 4 输出文件格式 (mir.collapse.fa, 名字的前3个字母为样品的特异标示，中间的数字表示第几条序列，是序列名字的唯一标示，第三部分是x加每个reads被测到的次数。三部分用下划线连起来作为fasta序列的名字。) &gt;ESB_1_x2 ACTGCCCTAAGTGCTCCTTCTGGC &gt;ESB_2_x25 ATAAGGTGCATCTAGTGCAGATA &gt;ESB_3_x100 TGAGGTAGTAGTTTGTGCTGTTT &gt;ESB_4_x4 TCCTACGAGTTGCATGGATTC 简化的短序列匹配程序 (map.py) 把short.fa中的序列比对到ref.fa, 输出短序列匹配到ref.fa文件中哪些序列的哪些位置 用到的知识点 find 输出格式 (输出格式为bed格式，第一列为匹配到的染色体，第二列和第三列为匹配到染色体序列的起始终止位置（位置标记以0为起始，代表第一个位置；终止位置不包含在内，第一个例子中所示序列的位置是(199,208](前闭后开，实际是chr1染色体第199-206的序列，0起始). 第4列为短序列自身的序列.)。 附加要求：可以只匹配到给定的模板链，也可以考虑匹配到模板链的互补链。这时第5列可以为短序列的名字，第六列为链的信息，匹配到模板链为’+‘，匹配到互补链为’-’。注意匹配到互补链时起始位置也是从模板链的5’端算起的。 chr1 199 208 TGGCGTTCA chr1 207 216 ACCCCGCTG chr2 63 70 AAATTGC chr3 0 7 AATAAAT 备注： 每个提到提到的“用到的知识点”为相对于前面的题目新增的知识点，请综合考虑。此外，对于不同的思路并不是所有提到的知识点都会用着，而且也可能会用到未提到的知识点。但是所有知识点都在前面的讲义部分有介绍。 每个程序对于你身边会写的人来说都很简单，因此你一定要克制住，独立去把答案做出，多看错误提示，多比对程序输出结果和预期结果的差异。 学习锻炼“读程序”，即对着文件模拟整个的读入、处理过程来发现可能的逻辑问题。 程序运行没有错误不代表你写的程序完成了你的需求，你要去查验输出结果是不是你想要的。 关于程序调试 在初写程序时，可能会出现各种各样的错误，常见的有缩进不一致，变量名字拼写错误，丢失冒号，文件名未加引号等，这时要根据错误提示查看错误类型是什么，出错的是哪一行来定位错误。当然，有的时候报错的行自身不一定有错，可能是其前面或后面的行出现了错误。 用脑袋运行程序：当程序写作完成后，自己尝试对着数据文件，一行一行的执行程序，来看程序的运行是否与自己想干的活一致，有没有纰漏。 当结果不符合预期时，要学会使用print来查看每步的操作是否正确，比如我读入了字典，我就打印下字典，看看读入的是不是我想要的，是否含有不该存在的字符；或者在每个判断句、函数调入的情况下打印个字符，来跟踪程序的运行轨迹。 2.6 函数操作 函数是重用的程序段。它们允许你给一块语句一个名称，然后你可以在你的程序的任何地方使用这个名称任意多次地运行这个语句块。这被称为 调用 函数。我们已经使用了许多内建的函数，比如len, range, input, int, str。 也可以导入特定包里面的函数，比如os.getcwd, sys.exit。 函数通过def关键字定义。def关键字后跟一个函数的 标识符 名称，然后跟一对圆括号。圆括号之中可以包括一些变量名，该行以冒号结尾。接下来是一块语句，它们是函数体。 ##自定义函数 def print_hello(): print(&quot;Hello, you!&quot;) print_hello() Hello, you! def hello(who): print(&quot;Hello, %s!&quot; % who) hello(&#39;you&#39;) hello(&#39;me&#39;) Hello, you! Hello, me! ##自定义函数 def sum_num(a, b): c = a + b return c d = sum_num(3, 4) d 7 局部变量和全局变量 全局作用：函数之外，从定义位置起，所有逻辑下游的语句都可以使用 局部作用：函数之内，出了函数就不可以被识别 局部可以使用global访问全局变量，而全局不能使用局部变量。 var = 1 def variable_test(): var = 2 print(&quot;var in variable_test is&quot;,var) print(&quot;var before running variable_test()&quot;, var) variable_test() print(&quot;var after running variable_test()&quot;, var) var before running variable_test() 1 var in variable_test is 2 var after running variable_test() 1 var = 1 def variable_test(): global var var = 2 print(&quot;var before running variable_test()&quot;, var) variable_test() print(&quot;var after running variable_test()&quot;, var) var before running variable_test() 1 var after running variable_test() 2 ## 全局变量在局部作用域中使用 def spam(): print(&quot;eggs in spam&quot;,eggs) eggs = 28 spam() eggs in spam 28 ## 全局变量在局部作用域中使用 ## 但若局部也有其定义，容易引发未定义冲突 def spam(): print(eggs) eggs = 29 eggs = 28 spam() print(eggs) --------------------------------------------------------------------------- UnboundLocalError Traceback (most recent call last) &lt;ipython-input-22-61f9fdfeb6fe&gt; in &lt;module&gt;() 6 7 eggs = 28 ----&gt; 8 spam() 9 print(eggs) &lt;ipython-input-22-61f9fdfeb6fe&gt; in spam() 1 # 全局变量在局部作用域中使用 2 def spam(): ----&gt; 3 print(eggs) 4 eggs = 29 5 UnboundLocalError: local variable &#39;eggs&#39; referenced before assignment ## 尽量避免名称相同的局部变量和全局变量 def spam(): eggs = &#39;spam local&#39; print(&quot;eggs in spam&quot;,eggs) # 输出spam local def bacon(): eggs = &#39;bacon local&#39; print(&quot;eggs in bacon&quot;, eggs) # 输出bacon local spam() print(&quot;eggs in bacon after running spam&quot;, eggs) # 输出bacon local eggs = &#39;global&#39; bacon() print(&quot;Global eggs&quot;, eggs) eggs in bacon bacon local eggs in spam spam local eggs in bacon after running spam bacon local Global eggs global print(&quot;把之前写过的语句块稍微包装下就是函数了\\n&quot;) def findAll(string, pattern): posL = [] pos = 0 for i in string: pos += 1 if i == pattern: posL.append(pos) #------------------- return posL ##------END of findAll------- a = findAll(&quot;ABCDEFDEACFBACACA&quot;, &quot;A&quot;) print(a) print(findAll(&quot;ABCDEFDEACFBACACA&quot;, &quot;B&quot;)) 把之前写过的语句块稍微包装下就是函数了 [1, 9, 13, 15, 17] [2, 12] def readFasta(file): aDict = {} for line in open(file): if line[0] == &#39;&gt;&#39;: name = line.strip() aDict[name] = [] else: aDict[name].append(line.strip()) #---------------------------------- for name, lineL in list(aDict.items()): aDict[name] = &#39;&#39;.join(lineL) return aDict print(readFasta(&quot;data/test1.fa&quot;)) seqD = readFasta(&quot;data/test2.fa&quot;) {&#39;&gt;NM_001011874 gene=Xkr4 CDS=151-2091&#39;: &#39;gcggcggcgggcgagcgggcgctggagtaggagctggggagcggcgcggccggggaaggaagccagggcg&#39;, &#39;&gt;NM_001195662 gene=Rp1 CDS=55-909&#39;: &#39;AGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCA&#39;, &#39;&gt;NM_0112835 gene=Rp15 CDS=128-6412&#39;: &#39;AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC&#39;, &#39;&gt;NM_011283 gene=Rp1 CDS=128-6412&#39;: &#39;AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC&#39;} {&#39;&gt;NM_001011874 gene=Xkr4 CDS=151-2091&#39;: &#39;gcggcggcgggcgagcgggcgctggagtaggagctggggagcggcgcggccggggaaggaagccagggcgaggcgaggaggtggcgggaggaggagacagcagggacaggTGTCAGATAAAGGAGTGCTCTCCTCCGCTGCCGAGGCATCATGGCCGCTAAGTCAGACGGGAGGCTGAAGATGAAGAAGAGCAGCGACGTGGCGTTCACCCCGCTGCAGAACTCGGACAATTCGGGCTCTGTGCAAGGACTGGCTCCAGGCTTGCCGTCGGGGTCCGGAG&#39;, &#39;&gt;NM_001195662 gene=Rp1 CDS=55-909&#39;: &#39;AAGCTCAGCCTTTGCTCAGATTCTCCTCTTGATGAAACAAAGGGATTTCTGCACATGCTTGAGAAATTGCAGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTG&#39;, &#39;&gt;NM_011283 gene=Rp1 CDS=128-6412&#39;: &#39;AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCACACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGGCGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATATGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA&#39;, &#39;&gt;NM_0112835 gene=Rp1 CDS=128-6412&#39;: &#39;AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCACACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGGCGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATATGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA&#39;} 2.6.1 作业（二） 将 “作业（一）” 中的程序块用函数的方式重写，并调用执行 用到的知识点 def func(para1,para2,…): func(para1,para2,…) 备注： 每个提到提到的“用到的知识点”为相对于前面的题目新增的知识点，请综合考虑。此外，对于不同的思路并不是所有提到的知识点都会用着，而且也可能会用到未提到的知识点。但是所有知识点都在前面的讲义部分有介绍。 每个程序对于你身边会写的人来说都很简单，因此你一定要克制住，独立去把答案做出，多看错误提示，多比对程序输出结果和预期结果的差异。 学习锻炼“读程序”，即对着文件模拟整个的读入、处理过程来发现可能的逻辑问题。 程序运行没有错误不代表你写的程序完成了你的需求，你要去插眼输出结果是不是你想要的。 关于程序调试 在初写程序时，可能会出现各种各样的错误，常见的有缩进不一致，变量名字拼写错误，丢失冒号，文件名未加引号等，这时要根据错误提示查看错误类型是什么，出错的是哪一行来定位错误。当然，有的时候报错的行自身不一定有错，可能是其前面或后面的行出现了错误。 当结果不符合预期时，要学会使用print来查看每步的操作是否正确，比如我读入了字典，我就打印下字典，看看读入的是不是我想要的，是否含有不该存在的字符；或者在每个判断句、函数调入的情况下打印个字符，来跟踪程序的运行轨迹。 2.7 模块 Python内置了很多标准库，如做数学运算的 math, 调用系统功能的 sys, 处理正则表达式的 re, 操作系统相关功能的 os等。我们主要关注两个库: * sys * sys.argv 处理命令行参数 * sys.exit() 退出函数 * sys.stdin 标准输入 * sys.stderr 标准错误 * os * os.system()或os.popen() 执行系统命令 * os.getcwd() 获取当前目录 * os.remove() 删除文件 import os os.getcwd() ##help(os.getcwd) ##os.remove(r&#39;D:\\project\\github\\PBR_training\\script\\splitName.py&#39;) ##os.system(&#39;rm file&#39;) &#39;/MPATHB/ct/ipython/notebook&#39; from os import getcwd getcwd() &#39;/MPATHB/ct/ipython/notebook&#39; 2.8 命令行参数 sys.argv是一个列表，存储了包含程序名字在内的传给程序的命令行参数。 %%writefile testSys.py import sys print(sys.argv) Writing testSys.py %run testSys &#39;abc&#39; 1 [&#39;testSys.py&#39;, &#39;abc&#39;, &#39;1&#39;] %%writefile cat.py import sys def read_print_file(filename): for line in open(filename): print(line, end=&quot;&quot;) ##------END read_print_file-------------------------- ##main函数及其调用部分是我个人写程序的固定格式，照搬就可以 def main(): #一般主程序会包含在main函数中，在文件的最后调用main函数即可运行程序 if len(sys.argv) &lt; 2: #如果命令行参数不足两个，则提示操作 #一般提示信息输出到标准错误 print(&quot;Usage: python %s filename&quot; % sys.argv[0], file=sys.stderr) sys.exit(0) file = sys.argv[1] read_print_file(file) ##--------END main------------------ ##这句话是说只有在文件被执行时才调用main函数。如果这个文件被其它文件调用，则不执行main函数。 if __name__ == &#39;__main__&#39;: main() Writing cat.py 关于__main__的解释见关于Python中的__main__和编程模板。 %run cat Usage: python cat.py filename %run cat data/test1.fa &gt;NM_001011874 gene=Xkr4 CDS=151-2091 gcggcggcgggcgagcgggcgctggagtaggagctggggagcggcgcggccggggaaggaagccagggcg &gt;NM_001195662 gene=Rp1 CDS=55-909 AGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCA &gt;NM_0112835 gene=Rp15 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC &gt;NM_011283 gene=Rp1 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC 使用 optparse，功能更强大 (保留内容) %%writefile skeleton.py ##!/usr/bin/env python desc = &#39;&#39;&#39; Functional description: &#39;&#39;&#39; import sys import os from time import localtime, strftime timeformat = &quot;%Y-%m-%d %H:%M:%S&quot; from optparse import OptionParser as OP def cmdparameter(argv): if len(argv) == 1: global desc print &gt;&gt;sys.stderr, desc cmd = &#39;python &#39; + argv[0] + &#39; -h&#39; os.system(cmd) sys.exit(0) usages = &quot;%prog -i file&quot; parser = OP(usage=usages) parser.add_option(&quot;-i&quot;, &quot;--input-file&quot;, dest=&quot;filein&quot;, metavar=&quot;FILEIN&quot;, help=&quot;The name of input file. \\ Standard input is accepted.&quot;) parser.add_option(&quot;-v&quot;, &quot;--verbose&quot;, dest=&quot;verbose&quot;, default=0, help=&quot;Show process information&quot;) parser.add_option(&quot;-d&quot;, &quot;--debug&quot;, dest=&quot;debug&quot;, default=False, help=&quot;Debug the program&quot;) (options, args) = parser.parse_args(argv[1:]) assert options.filein != None, &quot;A filename needed for -i&quot; return (options, args) ##-------------------------------------------------------------------- def main(): options, args = cmdparameter(sys.argv) #----------------------------------- file = options.filein verbose = options.verbose debug = options.debug #----------------------------------- if file == &#39;-&#39;: fh = sys.stdin else: fh = open(file) #-------------------------------- for line in fh: pass #-------------END reading file---------- #----close file handle for files----- if file != &#39;-&#39;: fh.close() #-----------end close fh----------- if verbose: print(&quot;--Successful %s&quot; % strftime(timeformat, localtime()), file=sys.stderr) if __name__ == &#39;__main__&#39;: startTime = strftime(timeformat, localtime()) main() endTime = strftime(timeformat, localtime()) fh = open(&#39;python.log&#39;, &#39;a&#39;) print(&quot;%s\\n\\tRun time : %s - %s &quot; % \\ (&#39; &#39;.join(sys.argv), startTime, endTime), file=sys.stderr) fh.close() Writing skeleton.py %run skeleton -h Usage: skeleton.py -i file Options: -h, --help show this help message and exit -i FILEIN, --input-file=FILEIN The name of input file. Standard input is accepted. -v VERBOSE, --verbose=VERBOSE Show process information -d DEBUG, --debug=DEBUG Debug the program 2.8.1 作业（三） 使 “作业（二）” 中的程序都能接受命令行参数 用到的知识点 import sys sys.argv import optparse 备注 每个提到提到的“用到的知识点”为相对于前面的题目新增的知识点，请综合考虑。此外，对于不同的思路并不是所有提到的知识点都会用着，而且也可能会用到未提到的知识点。但是所有知识点都在前面的讲义部分有介绍。 每个程序对于你身边会写的人来说都很简单，因此你一定要克制住，独立去把答案做出，多看错误提示，多比对程序输出结果和预期结果的差异。 学习锻炼“读程序”，即对着文件模拟整个的读入、处理过程来发现可能的逻辑问题。 程序运行没有错误不代表你写的程序完成了你的需求，你要去插眼输出结果是不是你想要的。 关于程序调试 在初写程序时，可能会出现各种各样的错误，常见的有缩进不一致，变量名字拼写错误，丢失冒号，文件名未加引号等，这时要根据错误提示查看错误类型是什么，出错的是哪一行来定位错误。当然，有的时候报错的行自身不一定有错，可能是其前面或后面的行出现了错误。 当结果不符合预期时，要学会使用print来查看每步的操作是否正确，比如我读入了字典，我就打印下字典，看看读入的是不是我想要的，是否含有不该存在的字符；或者在每个判断句、函数调入的情况下打印个字符，来跟踪程序的运行轨迹。 2.9 更多Python内容 2.9.1 单语句块 if True: print(&#39;yes&#39;) if True: print(&#39;yes&#39;) x = 5 y = 3 if x &gt; y: print(y) else: print(x) ##------------- print((y if y &lt; x else x)) print(x) yes yes 3 3 5 2.9.2 列表解析 生成新列表的简化的for循环 aList = [1, 2, 3, 4, 5] bList = [] for i in aList: bList.append(i * 2) ##----------------------------------- ##nameL = [line.strip() for line in open(file)] bList = [i * 2 for i in aList] print(bList) [2, 4, 6, 8, 10] print(&quot;列表解析可以做判断的&quot;) aList = [1, 2, 3, 4, 5] bList = [i * 2 for i in aList if i % 2 != 0] print(bList) 列表综合可以做判断的 [2, 6, 10] print(&quot;列表解析也可以嵌套的&quot;) aList = [1, 2, 3, 4, 5] bList = [5, 4, 3, 2, 1] bList = [i * j for i in aList for j in bList] ## for i in aList: ## for j in bList: ## print i * j print(bList) 列表综合也可以嵌套的 [5, 4, 3, 2, 1, 10, 8, 6, 4, 2, 15, 12, 9, 6, 3, 20, 16, 12, 8, 4, 25, 20, 15, 10, 5] 2.9.3 字典解析 aList = [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;] aDict = {i:aList.count(i) for i in aList} aDict {&#39;a&#39;: 2, &#39;b&#39;: 1, &#39;c&#39;: 1} bDict = {i:j*2 for i,j in aDict.items()} bDict {&#39;a&#39;: 4, &#39;b&#39;: 2, &#39;c&#39;: 2} 2.9.4 断言 设定运行过程中必须满足的条件，当情况超出预期时报错。常用于文件读入或格式判断时，有助于预防异常的读入或操作。 a = 1 b = 2 assert a == b, &quot;a is %s, b is %s&quot; % (a, b) if a == b: pass else: print(&quot;a is %s, b is %s&quot; % (a, b)) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) &lt;ipython-input-75-9c43179b4557&gt; in &lt;module&gt;() 1 a = 1 2 b = 2 ----&gt; 3 assert a == b, &quot;a is %s, b is %s&quot; % (a, b) 4 5 if a == b: AssertionError: a is 1, b is 2 2.9.5 更多字符串方法 is.X字符串方法 isalpha()是否只含字母 isalnum()是否只是字母或数字 isdecimal()是否只有数字 isspace()是否只有空格制表符换行 istitle()是否字符串为大写开头，后面均为小写字母 a = &#39;b1&#39; a.isalpha() False a = &#39;b c&#39; a.isalpha() False a = &#39;bc1&#39; a.isalnum() True a = &#39;1a&#39; a.isalnum() True &#39;,&#39;.join([&#39;i&#39;, &#39;love&#39;, &#39;python&#39;]) &#39;i,love,python&#39; &#39;***&#39;.join([&#39;i&#39;, &#39;love&#39;, &#39;python&#39;]) &#39;i***love***python&#39; &quot;linux R perl C python&quot;.split() [&#39;linux&#39;, &#39;R&#39;, &#39;perl&#39;, &#39;C&#39;, &#39;python&#39;] 文本对齐rjust() ljust() center() &#39;hello&#39;.rjust(10) &#39; hello&#39; &#39;hello&#39;.rjust(20,&#39;*&#39;) &#39;***************hello&#39; &#39;hello&#39;.center(20,&#39;-&#39;) &#39;-------hello--------&#39; def printPicnic(itemsDict, leftWidth, rightWidth): print(&#39;PICNIC ITEMS&#39;.center(leftWidth + rightWidth, &#39;-&#39;)) for k, v in itemsDict.items(): print(k.ljust(leftWidth, &#39;.&#39;) + str(v).rjust(rightWidth)) picnicItems = {&#39;sandwiches&#39;: 4, &#39;apples&#39;: 12, &#39;cups&#39;: 4, &#39;cookies&#39;: 8000} printPicnic(picnicItems, 12, 5) printPicnic(picnicItems, 20, 6) ---PICNIC ITEMS-- sandwiches.. 4 apples...... 12 cups........ 4 cookies..... 8000 -------PICNIC ITEMS------- sandwiches.......... 4 apples.............. 12 cups................ 4 cookies............. 8000 strip(),rstrip(),lstrip() 删除空白字符 spam = &#39; hello &#39; spam &#39; hello &#39; spam.strip() &#39;hello&#39; spam.rstrip() &#39; hello&#39; spam.lstrip() &#39;hello &#39; a = &#39;Hello world, welcome to python world&#39; a.strip(&#39;d&#39;) &#39;Hello world, welcome to python worl&#39; 2.9.6 lambda, map, filer, reduce (保留节目) lambda产生一个没有名字的函数，通常为了满足一次使用，其使用语法为lambda argument_list: expression。参数列表是用逗号分隔开的一个列表，表达式是这些参数的组合操作。 map执行一个循环操作，使用语法为map(func, seq)。第一个参数是要调用的函数或函数的名字，第二个参数是一个序列（如列表、字符串、字典）。map会以序列的每个元素为参数调用func，并新建一个输出列表。 filter用于过滤列表，使用语法为filter(func, list)。以第二个参数的每个元素调用func，返回值为True则保留，否则舍弃。 reduce连续对列表的元素应用函数，使用语法为reduce(func, list)。如果我们有一个列表aList = [1,2,3, … ,n ], 调用reduce(func, aList)后进行的操作为: 首先前两个元素会传入函数func做运算，返回值替换这两个元素，成为数组第一个元素aList = [func(1,2),3, … , n];然后当前的前两个元素再传图func函数做运算，返回值返回值替换这两个元素，成为数组第一个元素aList = [func(func(1,2),3), … , n]，直到列表只有一个元素。 print(&quot;求和函数&quot;) def f(x, y): return x + y print(f([1, 2, 3], [4, 5, 6])) print(f(10, 15)) 求和函数 [1, 2, 3, 4, 5, 6] 25 print(&quot;单个参数的map, lambda调用&quot;) aList = [1, 2, 3, 4, 5] print([x**2 for x in aList]) print(&quot;多个参数的map, lambda调用&quot;) def f(x, y): return x + y print(list(map(f, [1, 2, 3], [4, 5, 6]))) print(&quot;参数为字符串&quot;) print([x.upper() for x in &#39;acdf&#39;]) 单个参数的map, lambda调用 [1, 4, 9, 16, 25] 多个参数的map, lambda调用 [5, 7, 9] 参数为字符串 [&#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;F&#39;] print(&quot;输出所有的奇数&quot;) aList = [1, 2, 3, 4, 5] print([x for x in aList if x % 2]) 输出所有的奇数 [1, 3, 5] from functools import reduce print(&quot;列表求和&quot;) aList = [1, 2, 3, 4, 5] print(reduce(lambda a, b: a + b, aList)) 列表求和 15 from functools import reduce print(&quot;列表取最大值&quot;) aList = [1, 2, 3, 4, 5] print(reduce(lambda a, b: a if a &gt; b else b, aList)) 列表取最大值 5 2.9.7 exec, eval (执行字符串python语句, 保留节目) a = &#39;print(&quot;Executing a string as a command&quot;)&#39; exec(a) Executing a string as a command a = &#39;(2 + 3) * 5&#39; eval(a) 25 2.9.8 正则表达式 正则表达式通俗来讲就是模式匹配，给定一个模式，寻找可以配对的子串。在Python中，是使用re模块来实现的。 re.compile: 转换正则表达式为模式对象 re.match: 在待匹配字符串的起始匹配模式对象 re.search: 在待匹配字符串内部搜索第一个匹配对象 ## 示例，寻找起始密码子 import re cds = &quot;ATGACGCTCGGACGACTAATG&quot; start_codon = re.compile(&#39;ATG&#39;) start_codon_match = start_codon.match(cds) start_codon_match.group() &#39;ATG&#39; ## 如果前面有UTR，起始密码子不在第一位，则match找不到 mRNA = &quot;GTCAATGACGCTCGGACGACTAATG&quot; start_codon_match = start_codon.match(mRNA) if start_codon_match: print(start_codon_match.group()) else: print(&quot;No start codon found at the beginning of the given sequence.&quot;) No start codon at the beginning of the given sequence. ## 如果前面有UTR，起始密码子不在第一位，则需要使用search mRNA = &quot;GTCAATGACGCTCGGACGACTAATG&quot; start_codon_match = start_codon.search(mRNA) if start_codon_match: print(start_codon_match.group()) else: print(&quot;No start codon found in the given sequence.&quot;) ATG ## 如果想找出所有的终止子，则使用findall mRNA = &quot;ATGATGTAAUAATAGUGA&quot; stop_codon = re.compile(&#39;[TU]AA|[TU]AG|[TU]GA&#39;) ##stop_codon = re.compile(&#39;UAA|UAG|UGA&#39;) stop_codon.findall(mRNA) [&#39;TGA&#39;, &#39;TAA&#39;, &#39;UAA&#39;, &#39;TAG&#39;, &#39;UGA&#39;] 上面的模式中使用了正则表达式的2个特殊符号，|和[]。 A|B: 表示A或B有一个匹配就可以，如上面的TAA|TAG；如果想限定|两端的字符的范围，需要使用括号界定，如T(AA|T)AG则表示可以匹配TAAAG或TTAG。 [TU]: 中括号的任意字符都可以匹配，既该位置可以是T，也可以是U。此外还可以使用[A-Z]表示所有大写字母，[A-Za-z]表示所有英文字母，[0-9]表示所有阿拉伯数字，也可以写[W-Z5-9_]表示一部分字母、数字和下划线。 匹配某一个motif ## 匹配某一个motif， ## 要求motif ## 第1位为A， ## 第2位任意字符， ## 第3位为T， ## 中间间隔3-5个任意碱基， ## 随后一位是G seqL = [&quot;ACGTACGT&quot;, &quot;ACTCCCG&quot;,&quot;ACTCCGGG&quot;,&quot;AGTTTTTG&quot;] ## . 表示任意字符 (不包括换行) ## {3,5} 表示前面的字符出现次数为3-5次 pattern = re.compile(&quot;A.T.{3,5}G&quot;) print(&quot;Matched&quot;, &quot;\\t&quot;,&quot;Matched part&quot;) for seq in seqL: match = pattern.search(seq) if match: print(seq, &quot;\\t&quot;,match.group()) Matched Matched part ACTCCCG ACTCCCG ACTCCGGG ACTCCGGG AGTTTTTG AGTTTTTG 根据空格切割字符串 假如有这个一个字符串，\"A B C D , E, F\"，是由逗号,和数目不等的空格、TAB键或其组合连接起来的，想拆分开获取单独的部分。 &quot;A B C D , E, F&quot;.split(&#39; &#39;) [&#39;A&#39;, &#39;B&#39;, &#39;&#39;, &#39;C&#39;, &#39;D&#39;, &#39;,&#39;, &#39;E,&#39;, &#39;F&#39;] ## []都熟悉了， ## \\s: 表示所有的空白，包括空格，TAB键，换行等 ## +：表示前面的字符出现1次或多次 import re pattern = re.compile(&quot;[,\\s]+&quot;) seq = &quot;A B C D , E, F&quot; pattern.split(seq) [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] 记忆匹配 假如我们有一些fq.gz文件，想获取其文件名，并输出。 ## root和leaf是样品名字 ## 第一个下划线后面的是生物重复 rep1, rep2 ## 第二个下划线后的1和2分别代表双端测序的左端和右端。 fqL = [&quot;root_rep1_1.fq.gz&quot;, &quot;root_rep1_2.fq.gz&quot;, &quot;root_rep2_1.fq.gz&quot;,&quot;root_rep2_2.fq.gz&quot;, &quot;leaf_rep1_1.fq.gz&quot;, &quot;leaf_rep1_2.fq.gz&quot;, &quot;leaf_rep2_1.fq.gz&quot;,&quot;leaf_rep2_2.fq.gz&quot;] ## * 表示前面字符出现任意多次 ## () 在这表示记忆匹配，可以使用下标获取 ## \\ 是转义字符， \\.把.转化为一个正常字符，即这儿匹配的是一个真正的.， ## 而不是任意字符 pattern = re.compile(&quot;([^_]*)_([^_]*)_[12]\\.fq\\.gz&quot;) for fq in fqL: match = pattern.search(fq) sample = match.group(1) rep = match.group(2) print(sample,rep) root rep1 root rep1 root rep2 root rep2 leaf rep1 leaf rep1 leaf rep2 leaf rep2 匹配替换 国人的名字一般姓在前，名在后，老外写法是名在前，姓在后，现在需要做一个转换操作。 ## 把下面的名字转为姓在后，名在前 nameL = [&quot;Chen Tong&quot;, &quot;Liu Yongxin&quot;, &quot;Wang Ying&quot;] ## \\w: 表示单词字符，等同于[A-Za-z0-9_] pattern = re.compile(&quot;(\\w+) (\\w+)&quot;) ## \\2, \\1 表示记忆匹配的第一个和第二个，具体的计数方式已最左侧括号为准， ## 最左第一个括号是\\1, 第二个是\\2. for name in nameL: print(pattern.sub(r&quot;\\2 \\1&quot;, name)) Tong Chen Yongxin Liu Ying Wang 更多正则表达式的规则见下图，剩下的就是勤学多练了。 图片来源于 https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html 2.10 Python画图 2.10.0.1 Figure和Subplot import matplotlib.pyplot as plt import numpy as np import pandas as pd from numpy.random import randn x = [1, 3, 5, 7, 9, 10, 23, 45, 45, 56] y = [2, 4, 6, 8, 11, 12, 23, 45, 56, 78] fig = plt.figure() ax1 = fig.add_subplot(2, 2, 1) # 创建4个图的Figure对象，最后的1为选中第一个 ax2 = fig.add_subplot(2, 2, 2) ax3 = fig.add_subplot(2, 2, 3) ax4 = fig.add_subplot(2, 2, 4) ax1.hist(x, y) ax2.scatter(x, y) ax4.plot(x, y) plt.show() fig, axes = plt.subplots(2, 3) axes array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000B5D88D0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000000009A87FD0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000B3467B8&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x0000000009CF0390&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000B6CC080&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x000000000B5D9978&gt;]], dtype=object) 创建2 X 3图像，可以相当于对二维数组进行索引 参数 说明 nrows subplot行数 ncols subplot列数 sharex 所有图使用相同的x轴 sharey 所有图使用相同的y轴 subplot_kw 用于创建各subplot的关键字字典 ```| #### 调整subplot周围间距 subplots_ajust(left=None,bottom=None,right=None,top=None,wspace=None,hspace=None) wspace和hspace控制宽度和高度的百分比 ```python fig, axes = plt.subplots(2, 2, sharex=True, sharey=True) for i in range(2): for j in range(2): axes[i, j].hist(randn(500), bins=50, color=&#39;k&#39;, alpha=0.5) plt.subplots_adjust(wspace=0, hspace=0) plt.show() fig, axes = plt.subplots(2, 2, sharex=True, sharey=True) for i in range(2): for j in range(2): axes[i, j].hist(randn(500), bins=50, color=&#39;k&#39;, alpha=0.5) plt.subplots_adjust(wspace=1, hspace=1) plt.show() 2.10.0.2 颜色 标记和线型 &quot;&quot;&quot; 绘制绿色虚线 ax.plot(x,y,&#39;g--&#39;) 另一种方式 ax.plot(x,y,linestyle=&#39;--&#39;,color=&#39;g&#39;) 标记点（maker） &quot;&quot;&quot; fig, axes = plt.subplots(1, 2) axes[0].plot(randn(10), &#39;g--&#39;) # green --- axes[1].plot(randn(10), &#39;ko--&#39;) # k：black o：圆点 plt.show() 2.10.0.3 刻度、标签和图例 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(randn(100)) plt.show() &quot;&quot;&quot;修改上图的轴&quot;&quot;&quot; fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(randn(100)) ticks = ax.set_xticks([0, 25, 50, 75, 100]) # 设置刻度 labels = ax.set_xticklabels( [&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;forth&#39;, &#39;fifth&#39;], rotation=30, fontsize=&#39;small&#39;) # 设置x轴标签 ax.set_title(&#39;my first matplot plot&#39;) # 设置图片标题 ax.set_xlabel(&#39;Stages&#39;) # 设置x轴名称 plt.show() 2.10.0.4 添加图例legend https://matplotlib.org/api/legend_api.html?highlight=legend#module-matplotlib.legend ‘best’ 0 ‘upper right’ 1 ‘upper left’ 2 ‘lower left’ 3 ‘lower right’ 4 ‘right’ 5 ‘center left’ 6 ‘center right’ 7 ‘lower center’ 8 ‘upper center’ 9 ‘center’ 10 bbox_to_anchor=（0.5,0.8） bbox_to_anchor被赋予的二元组中，第一个数值用于控制legend的左右移动，值越大越向右边移动， 第二个数值用于控制legend的上下移动，值越大，越向上移动 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(randn(10), &#39;k&#39;, label=&#39;one&#39;) # 画一条线，k黑色 ax.plot(randn(10), &#39;g--&#39;, label=&#39;two&#39;) # 画第二条线，g绿色 - -类型 ax.plot(randn(10), &#39;ro--&#39;, label=&#39;three&#39;) # 画第三条线红色 ，类型 ... ax.legend(loc=0, bbox_to_anchor=(0.5, 0.9)) plt.show() 2.10.0.5 注解 x = [2, 4, 6, 8, 10, 12] y = [1, 3, 5, 7, 9, 11] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ##ax = fig ax.plot(x, y, &#39;r--&#39;) ax.text(2, 4, &#39;hello python&#39;) plt.show() 2.10.0.6 图片保存 x = [2, 4, 6, 8, 10, 12] y = [1, 3, 5, 7, 9, 11] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(x, y, &#39;r--&#39;) ax.text(2, 4, &#39;hello python&#39;) ## bbox_inches减除当前图片周围空白部分 plt.savefig(&#39;figpath.jpg&#39;, dpi=300, bbox_inches=&#39;tight&#39;) 2.10.0.7 matplotlib配置 绘图之前可以调整各种参数字体，全局所有图片的大小等。 实例 2.10.0.7.1 绘制散点图 x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.scatter(x, # x轴数据为汽车速度 y, # y轴数据为汽车的刹车距离 s=20, # 设置点的大小 c=&#39;green&#39;, # 设置点的颜色 marker=&#39;s&#39;, # 设置点的形状 alpha=0.9, # 设置点的透明度 linewidths=0.8, # 设置散点边界的粗细 edgecolors=&#39;red&#39; # 设置散点边界的颜色 ) plt.title(&#39;simple scatter plot&#39;) plt.xlabel(&#39;X&#39;) # x轴名称 plt.ylabel(&#39;Y&#39;) plt.show() # 展示绘图 2.10.0.7.2 折线图 x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.plot(x, # x轴数据 y, # y轴数据 linestyle=&#39;-&#39;, # 折线类型 linewidth=2, # 折线宽度 color=&#39;blue&#39;, # 折线颜色 marker=&#39;o&#39;, # 点的形状 markersize=8, # 点的大小 markeredgecolor=&#39;black&#39;, # 点的边框色 markerfacecolor=&#39;red&#39;) # 点的填充色 ## 添加标题和坐标轴标签 plt.title(&#39;line plot&#39;) plt.xlabel(&#39;X&#39;) plt.ylabel(&#39;Y&#39;) plt.show() 2.10.0.7.3 直方图 import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.hist(np.random.randn(50), # 绘图数据 bins=50, # 指定直方图的条形数为20个 color=&#39;red&#39;, # 指定填充色 edgecolor=&#39;k&#39;, # 指定直方图的边界色 label=&#39;histogram&#39;) # 为直方图呈现标签 plt.show() 2.10.0.8 直条图 x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.bar(x, y, color=&#39;steelblue&#39;, alpha=0.8) plt.title(&#39;bar plot&#39;) plt.ylim([0, 40]) plt.show() x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.barh(x, y, color=&#39;steelblue&#39;, alpha=0.8) plt.title(&#39;bar plot&#39;) plt.show() 2.10.0.9 箱线图 x = [1, 2, 3, 4, 5, 6] plt.boxplot(x, patch_artist=True, # 箱体添加颜色 labels=[&#39;boxplot&#39;], # 添加具体的标签名称 showmeans=True, ) ## 显示图形 plt.show() np.random.seed(2) # 设置随机种子 df = pd.DataFrame(np.random.rand(5, 4), columns=([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])) df .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } A B C D 0 0.435995 0.025926 0.549662 0.435322 1 0.420368 0.330335 0.204649 0.619271 2 0.299655 0.266827 0.621134 0.529142 3 0.134580 0.513578 0.184440 0.785335 4 0.853975 0.494237 0.846561 0.079645 data = [] for i in range(4): data.append(df.iloc[:, i]) data [0 0.435995 1 0.420368 2 0.299655 3 0.134580 4 0.853975 Name: A, dtype: float64, 0 0.025926 1 0.330335 2 0.266827 3 0.513578 4 0.494237 Name: B, dtype: float64, 0 0.549662 1 0.204649 2 0.621134 3 0.184440 4 0.846561 Name: C, dtype: float64, 0 0.435322 1 0.619271 2 0.529142 3 0.785335 4 0.079645 Name: D, dtype: float64] plt.boxplot(data) plt.show() plt.boxplot(x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None) x：指定要绘制箱线图的数据； notch：是否是凹口的形式展现箱线图，默认非凹口； sym：指定异常点的形状，默认为+号显示； vert：是否需要将箱线图垂直摆放，默认垂直摆放； whis：指定上下须与上下四分位的距离，默认为1.5倍的四分位差； positions：指定箱线图的位置，默认为[0,1,2…]； widths：指定箱线图的宽度，默认为0.5； patch_artist：是否填充箱体的颜色； meanline：是否用线的形式表示均值，默认用点来表示； showmeans：是否显示均值，默认不显示； showcaps：是否显示箱线图顶端和末端的两条线，默认显示； showbox：是否显示箱线图的箱体，默认显示； showfliers：是否显示异常值，默认显示； boxprops：设置箱体的属性，如边框色，填充色等； labels：为箱线图添加标签，类似于图例的作用； filerprops：设置异常值的属性，如异常点的形状、大小、填充色等； medianprops：设置中位数的属性，如线的类型、粗细等； meanprops：设置均值的属性，如点的大小、颜色等； capprops：设置箱线图顶端和末端线条的属性，如颜色、粗细等； whiskerprops：设置须的属性，如颜色、粗细、线的类型等； 2.10.0.9.1 饼图 data = [0.2, 0.3, 0.4, 0.1] plt.pie(data) plt.show() plt.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False) x：指定绘图的数据； explode：指定饼图某些部分的突出显示，即呈现爆炸式； labels：为饼图添加标签说明，类似于图例说明； colors：指定饼图的填充色； autopct：自动添加百分比显示，可以采用格式化的方法显示； pctdistance：设置百分比标签与圆心的距离； shadow：是否添加饼图的阴影效果； labeldistance：设置各扇形标签（图例）与圆心的距离； startangle：设置饼图的初始摆放角度； radius：设置饼图的半径大小； counterclock：是否让饼图按逆时针顺序呈现； wedgeprops：设置饼图内外边界的属性，如边界线的粗细、颜色等； textprops：设置饼图中文本的属性，如字体大小、颜色等； center：指定饼图的中心点位置，默认为原点 frame：是否要显示饼图背后的图框，如果设置为True的话，需要同时控制图框x轴、y轴的范围和饼图的中心位置； %matplotlib inline from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) X, Y, Z = axes3d.get_test_data(0.05) cset = ax.contour(X, Y, Z, cmap=cm.coolwarm) ax.clabel(cset, fontsize=9, inline=1) plt.show() import matplotlib as mpl from mpl_toolkits.mplot3d import Axes3D import numpy as np import matplotlib.pyplot as plt mpl.rcParams[&#39;legend.fontsize&#39;] = 10 fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;) ##theta = np.linspace(-4 * np.pi, 4 * np.pi, 100) ##z = np.linspace(-2, 2, 100) ##r = z**2 + 1 ##x = r * np.sin(theta) ##y = r * np.cos(theta) x = [1, 2, 3] y = [1.5, 1, 2] z = [2, 1, 3] ax.plot(x, y, z, label=&#39;parametric curve&#39;) ax.legend() plt.show() from matplotlib import pyplot as plt from matplotlib.patches import Rectangle someX, someY = 0.5, 0.5 fig, ax = plt.subplots() currentAxis = plt.gca() currentAxis.add_patch(Rectangle((someX - 0.1, someY - 0.1), 0.2, 0.2, alpha=1, facecolor=&#39;none&#39;)) plt.show() from mpl_toolkits.mplot3d import Axes3D from mpl_toolkits.mplot3d.art3d import Poly3DCollection import matplotlib.pyplot as plt fig = plt.figure() ax = Axes3D(fig) x = [1,2,2] y = [1,0,2] z = [1,2,0] verts = [zip(x, y,z)] ax.add_collection3d(Poly3DCollection(verts,edgecolors=&#39;red&#39;, facecolors=&#39;red&#39;)) x = [0,1,1] y = [0,0,1] z = [0,1,0] verts = [zip(x, y,z)] verts = [[(1,1,1), (2,0,2),(2,2,0)],[(0,0,0),(1,0,1),(1,1,0)]] ax.add_collection3d(Poly3DCollection(verts)) plt.show() from mpl_toolkits.mplot3d import Axes3D from mpl_toolkits.mplot3d.art3d import Poly3DCollection import matplotlib.pyplot as plt fig = plt.figure() ax = Axes3D(fig) verts = [[(0.5,0.5,0.5), (1.2,0,1.2),(1.2,1.2,0)],[(0,0,0),(1,0,1),(1,1,0)]] ax.add_collection3d(Poly3DCollection(verts, edgecolors=[&#39;blue&#39;,&#39;red&#39;], facecolors=[&#39;blue&#39;,&#39;red&#39;])) plt.show() from matplotlib import pyplot as plt from mpl_toolkits.mplot3d.art3d import Poly3DCollection fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) x = [0.5, 1.2, 1.2, 0, 1, 1] y = [0.5, 0, 1.2, 0, 0, 1] z = [0.5, 1.2, 0, 0, 1, 0] poly3d = [[(0.5,0.5,0.5), (1.2,0,1.2),(1.2,1.2,0)],[(0,0,0),(1,0,1),(1,1,0)]] ax.scatter(x,y,z) ax.add_collection3d(Poly3DCollection(poly3d, edgecolors=[&#39;red&#39;,&#39;blue&#39;], facecolors=&#39;w&#39;, linewidths=1, alpha=0.5)) plt.show() 2.11 Reference http://www.byteofpython.info/ http://woodpecker.org.cn/abyteofpython_cn/chinese/index.html http://www.python-course.eu/ http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2008/ http://my.oschina.net/taogang/blog/286954 "],["Python_plot_WXN.html", "3 Python作图 3.1 绘图基础 3.2 绘图实例", " 3 Python作图 3.1 绘图基础 3.1.1 Figure和Subplot import matplotlib.pyplot as plt import numpy as np import pandas as pd from numpy.random import randn x = [1, 3, 5, 7, 9, 10, 23, 45, 45, 56] y = [2, 4, 6, 8, 11, 12, 23, 45, 56, 78] fig = plt.figure() # 创建一个Figure ax1 = fig.add_subplot(2, 2, 1) # 创建4个图的Figure对象，最后的1为选中第一个 ax2 = fig.add_subplot(2, 2, 2) ax3 = fig.add_subplot(2, 2, 3) ax4 = fig.add_subplot(2, 2, 4) ax1.hist(x, y) # 在第一图中绘制直方图 ax2.scatter(x, y) # 散点图 ax4.plot(x, y) # 线图 plt.show() fig, axes = plt.subplots(2, 3) # 创建一个Figure 绘制2 X3 图 fig axes array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f8436a71780&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f842f2438d0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f842f27d9e8&gt;], [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f842f236978&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f842f1f19b0&gt;, &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f842f199710&gt;]], dtype=object) 创建2 X 3图像，可以相当于对二维数组进行索引 参数 说明 nrows subplot行数 ncols subplot列数 sharex 所有图使用相同的x轴 sharey 所有图使用相同的y轴 subplot_kw 用于创建各subplot的关键字字典 ```| ### 调整subplot周围间距 subplots_ajust(left=None,bottom=None,right=None,top=None,wspace=None,hspace=None) wspace和hspace控制宽度和高度 ```python fig, axes = plt.subplots(2, 2, sharex=True, sharey=True) for i in range(2): for j in range(2): axes[i, j].hist(randn(500), bins=50, color=&#39;k&#39;, alpha=0.5) plt.subplots_adjust(wspace=0, hspace=0) plt.show() fig, axes = plt.subplots(2, 2, sharex=True, sharey=True) for i in range(2): for j in range(2): axes[i, j].hist(randn(500), bins=50, color=&#39;k&#39;, alpha=0.5) plt.subplots_adjust(wspace=2, hspace=0.5) plt.show() fig 3.1.2 颜色 标记和线型 &quot;&quot;&quot; 绘制绿色虚线 ax.plot(x,y,&#39;g--&#39;) 另一种方式 ax.plot(x,y,linestyle=&#39;--&#39;,color=&#39;g&#39;) 标记点（maker） &quot;&quot;&quot; fig, axes = plt.subplots(1, 2) axes[0].plot(randn(10), &#39;g--&#39;) # green --- axes[1].plot(randn(10), &#39;ko--&#39;) # k：black o：圆点 plt.show() character description &#39;-&#39; solid line style &#39;--&#39; dashed line style &#39;-.&#39; dash-dot line style &#39;:&#39; dotted line style &#39;.&#39; point marker &#39;,&#39; pixel marker &#39;o&#39; circle marker &#39;v&#39; triangle_down marker &#39;^&#39; triangle_up marker &#39;&lt;&#39; triangle_left marker &#39;&gt;&#39; triangle_right marker &#39;1&#39; tri_down marker &#39;2&#39; tri_up marker &#39;3&#39; tri_left marker &#39;4&#39; tri_right marker &#39;s&#39; square marker &#39;p&#39; pentagon marker &#39;*&#39; star marker &#39;h&#39; hexagon1 marker &#39;H&#39; hexagon2 marker &#39;+&#39; plus marker &#39;x&#39; x marker &#39;D&#39; diamond marker &#39;d&#39; thin_diamond marker &#39;|&#39; vline marker &#39;_&#39; hline marker The following color abbreviations are supported: character color ‘b’ blue ‘g’ green ‘r’ red ‘c’ cyan(青色) ‘m’ magenta（紫红色） ‘y’ yellow ‘k’ black ‘w’ white https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot 3.1.3 刻度、标签和图例 fig = plt.figure() # 创建一个Figure ax = fig.add_subplot(1, 1, 1) ax.plot(randn(100)) plt.show() &quot;&quot;&quot;修改上图的轴&quot;&quot;&quot; fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(randn(100)) ticks = ax.set_xticks([0, 25, 50, 75, 100]) # 设置刻度 labels = ax.set_xticklabels( [&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;forth&#39;, &#39;fifth&#39;], rotation=30, fontsize=&#39;small&#39;) # 设置x轴标签 ax.set_title(&#39;my first matplot plot&#39;) # 设置图片标题 ax.set_xlabel(&#39;Stages&#39;) # 设置x轴名称 plt.show() 3.1.4 添加图例legend https://matplotlib.org/api/legend_api.html?highlight=legend#module-matplotlib.legend ‘best’ 0 ‘upper right’ 1 ‘upper left’ 2 ‘lower left’ 3 ‘lower right’ 4 ‘right’ 5 ‘center left’ 6 ‘center right’ 7 ‘lower center’ 8 ‘upper center’ 9 ‘center’ 10 bbox_to_anchor=（0.5,0.8） bbox_to_anchor被赋予的元组中，第一个数值用于控制legend的左右移动，值越大越向右边移动， 第二个数值用于控制legend的上下移动，值越大，越向上移动 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(randn(10), &#39;k&#39;, label=&#39;one&#39;) # 画一条线，k黑色 ax.plot(randn(10), &#39;g--&#39;, label=&#39;two&#39;) # 画第二条线，g绿色 - -类型 ax.plot(randn(10), &#39;ro--&#39;, label=&#39;three&#39;) # 画第三条线红色 ，类型 ... ax.legend(loc=0, bbox_to_anchor=(1, 1)) plt.show() 3.1.5 注解 x = [2, 4, 6, 8, 10, 12] y = [1, 3, 5, 7, 9, 11] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(x, y, &#39;r--&#39;) ax.text(2, 4, &#39;hello python&#39;) plt.show() ax = plt.subplot(111) t = np.arange(0.0, 5.0, 0.01) s = np.cos(2 * np.pi * t) line, = plt.plot(t, s, lw=2) plt.annotate(&#39;local max&#39;, xy=(2, 1), xytext=(3, 1.5), arrowprops=dict(facecolor=&#39;blue&#39;) # xy=（要注释的点），xytext=(注释在图中的位置) ) plt.ylim(-2, 2) plt.show() 3.1.6 图片保存 x = [2, 4, 6, 8, 10, 12] y = [1, 3, 5, 7, 9, 11] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(x, y, &#39;r--&#39;) ax.text(2, 4, &#39;hello python&#39;) # bbox_inches减除当前图片周围空白部分 plt.savefig(&#39;figpath.jpg&#39;, dpi=300, bbox_inches=&#39;tight&#39;) 3.2 绘图实例 3.2.1 绘制散点图 x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.scatter(x, # x轴数据 y, # y轴数据 s=20, # 设置点的大小 c=&#39;green&#39;, # 设置点的颜色 marker=&#39;s&#39;, # 设置点的形状 alpha=0.9, # 设置点的透明度 linewidths=0.8, # 设置散点边界的粗细 edgecolors=&#39;red&#39; # 设置散点边界的颜色 ) plt.title(&#39;simple scatter plot&#39;) plt.xlabel(&#39;X&#39;) # x轴名称 plt.ylabel(&#39;Y&#39;) plt.show() # 展示绘图 3.2.2 折线图 x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.plot(x, # x轴数据 y, # y轴数据 linestyle=&#39;-&#39;, # 折线类型 linewidth=2, # 折线宽度 color=&#39;blue&#39;, # 折线颜色 marker=&#39;o&#39;, # 点的形状 markersize=8, # 点的大小 markeredgecolor=&#39;black&#39;, # 点的边框色 markerfacecolor=&#39;red&#39;) # 点的填充色 # 添加标题和坐标轴标签 plt.title(&#39;line plot&#39;) plt.xlabel(&#39;X&#39;) plt.ylabel(&#39;Y&#39;) plt.show() import numpy as np import matplotlib.pyplot as plt t = np.arange(0., 5., 0.2) t array([ 0. , 0.2, 0.4, 0.6, 0.8, 1. , 1.2, 1.4, 1.6, 1.8, 2. , 2.2, 2.4, 2.6, 2.8, 3. , 3.2, 3.4, 3.6, 3.8, 4. , 4.2, 4.4, 4.6, 4.8]) # red dashes, blue squares and green triangles plt.plot(t, t, &#39;r--&#39;, t, t**2, &#39;bs&#39;, t, t**3, &#39;g&#39;) plt.show() # 同一效果 fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.plot(t, t, &#39;r--&#39;) ax.plot(t, t**2, &#39;bs&#39;) # &#39;bs&#39;表示blue square marker ax.plot(t, t**3, &#39;g&#39;) fig 3.2.3 直方图 import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.hist(np.random.randn(50), # 绘图数据 bins=50, # 指定直方图的条形数 color=&#39;red&#39;, # 指定填充色 edgecolor=&#39;k&#39;) # 指定直方图的边界色k :black plt.show() 3.2.4 直条图 x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.bar(x, y, color=&#39;steelblue&#39;, alpha=0.8) plt.title(&#39;bar plot&#39;) plt.ylim([0, 40]) plt.show() x = [1, 2, 3, 4, 5, 6] y = [1, 4, 9, 16, 25, 36] plt.barh(x, y, color=&#39;steelblue&#39;, alpha=0.8) plt.title(&#39;bar plot&#39;) plt.show() 3.2.5 箱线图 x = [1, 2, 3, 4, 5, 6] plt.boxplot(x, patch_artist=True, # 箱体添加颜色 labels=[&#39;boxplot&#39;], # 添加具体的标签名称 showmeans=True) # 显示图形 plt.show() np.random.seed(2) # 设置随机种子 df = pd.DataFrame(np.random.rand(5, 4), columns=([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])) df .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } A B C D 0 0.435995 0.025926 0.549662 0.435322 1 0.420368 0.330335 0.204649 0.619271 2 0.299655 0.266827 0.621134 0.529142 3 0.134580 0.513578 0.184440 0.785335 4 0.853975 0.494237 0.846561 0.079645 data = [] for i in range(4): data.append(df.iloc[:, i]) data [0 0.435995 1 0.420368 2 0.299655 3 0.134580 4 0.853975 Name: A, dtype: float64, 0 0.025926 1 0.330335 2 0.266827 3 0.513578 4 0.494237 Name: B, dtype: float64, 0 0.549662 1 0.204649 2 0.621134 3 0.184440 4 0.846561 Name: C, dtype: float64, 0 0.435322 1 0.619271 2 0.529142 3 0.785335 4 0.079645 Name: D, dtype: float64] plt.boxplot(data) plt.show() plt.boxplot(x, notch=None, sym=None, vert=None, whis=None, positions=None, widths=None, patch_artist=None, meanline=None, showmeans=None, showcaps=None, showbox=None, showfliers=None, boxprops=None, labels=None, flierprops=None, medianprops=None, meanprops=None, capprops=None, whiskerprops=None) x：指定要绘制箱线图的数据； notch：是否凹口的形式展现箱线图，默认非凹口； sym：指定异常点的形状，默认为+号显示； vert：是否需要将箱线图垂直摆放，默认垂直摆放； whis：指定上下须与上下四分位的距离，默认为1.5倍的四分位差； positions：指定箱线图的位置，默认为[0,1,2…]； widths：指定箱线图的宽度，默认为0.5； patch_artist：是否填充箱体的颜色； meanline：是否用线的形式表示均值，默认用点来表示； showmeans：是否显示均值，默认不显示； showcaps：是否显示箱线图顶端和末端的两条线，默认显示； showbox：是否显示箱线图的箱体，默认显示； showfliers：是否显示异常值，默认显示； boxprops：设置箱体的属性，如边框色，填充色等； labels：为箱线图添加标签，类似于图例的作用； filerprops：设置异常值的属性，如异常点的形状、大小、填充色等； medianprops：设置中位数的属性，如线的类型、粗细等； meanprops：设置均值的属性，如点的大小、颜色等； capprops：设置箱线图顶端和末端线条的属性，如颜色、粗细等； whiskerprops：设置须的属性，如颜色、粗细、线的类型等； 3.2.6 饼图 data = [0.2, 0.3, 0.4, 0.1] plt.pie(data) plt.show() plt.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False) x：指定绘图的数据； explode：指定饼图某些部分的突出显示，即呈现爆炸式； labels：为饼图添加标签说明，类似于图例说明； colors：指定饼图的填充色； autopct：自动添加百分比显示，可以采用格式化的方法显示； pctdistance：设置百分比标签与圆心的距离； shadow：是否添加饼图的阴影效果； labeldistance：设置各扇形标签（图例）与圆心的距离； startangle：设置饼图的初始摆放角度； radius：设置饼图的半径大小； counterclock：是否让饼图按逆时针顺序呈现； wedgeprops：设置饼图内外边界的属性，如边界线的粗细、颜色等； textprops：设置饼图中文本的属性，如字体大小、颜色等； center：指定饼图的中心点位置，默认为原点 frame：是否要显示饼图背后的图框，如果设置为True的话，需要同时控制图框x轴、y轴的范围和饼图的中心位置； 3.2.7 绘制基因矩阵的热图 # 来源于百度经验 import numpy as np from matplotlib import pyplot as plt from matplotlib import cm from matplotlib import axes def draw_heatmap(data, xlabels, ylabels): # 自定义函数，3个参数 cmap = cm.Blues figure = plt.figure(facecolor=&#39;w&#39;) ax = figure.add_subplot(1, 1, 1, position=[0.1, 0.15, 0.8, 0.8]) ax.set_yticks(range(len(ylabels))) ax.set_yticklabels(ylabels) ax.set_xticks(range(len(xlabels))) ax.set_xticklabels(xlabels) vmax = data[0][0] vmin = data[0][0] for i in data: for j in i: if j &gt; vmax: vmax = j if j &lt; vmin: vmin = j map = ax.imshow(data, interpolation=&#39;nearest&#39;, cmap=cmap, aspect=&#39;auto&#39;, vmin=vmin, vmax=vmax) # interpolation插值，cmap:colormap cb = plt.colorbar(mappable=map, cax=None, ax=None, shrink=0.5) # 绘制颜色条 plt.show() a = np.random.rand(10, 10) xlabels = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;] ylabels = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;] draw_heatmap(a, xlabels, ylabels) import pandas as pd import numpy as np df = pd.DataFrame(np.random.randn(5, 6)) df .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } 0 1 2 3 4 5 0 -0.596967 0.080979 -1.890122 -0.629949 -1.187113 -0.002018 1 1.264042 0.044216 -1.669342 0.805476 -0.173634 -0.051918 2 0.793684 1.746997 0.785712 -0.157126 0.072688 0.310271 3 0.988716 0.404472 0.967111 -0.612160 -0.259917 -0.067299 4 0.033911 1.177149 -0.914153 -0.579912 -0.100110 0.747296 plt.imshow(df) plt.show() 读入基因表达数据，绘制某基因的箱线图 %cd F: \\mega\\hello\\python\\python课程包\\merge import os os.getcwd() F:\\mega\\hello\\python\\python课程包\\merge &#39;F:\\\\mega\\\\hello\\\\python\\\\python课程包\\\\merge&#39; import pandas as pd df = pd.read_table(&quot;hello.xls&quot;, sep=&quot;\\t&quot;, index_col=0, header=0) df.head(5) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } MCF10F MCF12A T47DKBluc UACC812 UACC893 ZR751 ZR7530 ZR75B EnsEMBL_Gene_ID ENSG00000000003 91.574061 13.040870 73.387310 26.579280 50.676579 31.812999 121.459918 2.293898 ENSG00000001167 164.221408 170.101403 106.114416 138.140311 106.342032 68.458022 73.910964 61.625519 ENSG00000005471 0.000000 0.073680 0.536226 0.440649 0.066213 0.548865 0.611036 0.556531 ENSG00000066629 24.630773 18.627459 34.619613 79.187879 0.058835 25.493800 25.917323 32.528112 ENSG00000154258 0.896612 0.214261 0.000000 0.040907 0.021120 0.000000 0.033571 0.177808 df.shape (36953, 8) df.size df.ndim df.values array([[ 9.15740610e+01, 1.30408701e+01, 7.33873101e+01, ..., 3.18129988e+01, 1.21459918e+02, 2.29389818e+00], [ 1.64221408e+02, 1.70101403e+02, 1.06114416e+02, ..., 6.84580224e+01, 7.39109636e+01, 6.16255191e+01], [ 0.00000000e+00, 7.36800986e-02, 5.36226145e-01, ..., 5.48864965e-01, 6.11036013e-01, 5.56531115e-01], ..., [ 2.71701826e+00, 5.55925621e+00, 2.93123839e+00, ..., 3.71765369e+00, 2.42540639e+00, 4.56656068e+00], [ 1.74266818e+01, 3.72964028e+00, 3.49013629e+01, ..., 5.04982802e+01, 3.75784692e+01, 4.79996494e+01], [ 0.00000000e+00, 0.00000000e+00, 3.52988338e+00, ..., 8.15259649e+00, 6.08178979e-01, 3.25252710e+00]]) control = [] for i in range(3): control.append(df.iloc[0, i]) control [91.574060981100004, 13.0408701074, 73.387310079800002] test = [] for i in range(3, 8): test.append(df.iloc[0, i]) test [26.579280359299997, 50.676578905299998, 31.812998762600003, 121.4599177489, 2.2938981847999997] gene = [control, test] fig = plt.figure() ax = fig.add_subplot(1, 1, 1) ax.boxplot(gene, patch_artist=True, # 箱体添加颜色 labels=[&#39;test&#39;, &#39;control&#39;], # 添加具体的标签名称 showmeans=True, ) plt.show() 热图 df2 = df.head(10) # 取部分数据 df2 .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } MCF10F MCF12A T47DKBluc UACC812 UACC893 ZR751 ZR7530 ZR75B EnsEMBL_Gene_ID ENSG00000000003 91.574061 13.040870 73.387310 26.579280 50.676579 31.812999 121.459918 2.293898 ENSG00000001167 164.221408 170.101403 106.114416 138.140311 106.342032 68.458022 73.910964 61.625519 ENSG00000005471 0.000000 0.073680 0.536226 0.440649 0.066213 0.548865 0.611036 0.556531 ENSG00000066629 24.630773 18.627459 34.619613 79.187879 0.058835 25.493800 25.917323 32.528112 ENSG00000154258 0.896612 0.214261 0.000000 0.040907 0.021120 0.000000 0.033571 0.177808 ENSG00000154262 3.431313 2.481636 0.000000 0.383060 0.000000 0.000000 0.000000 0.105758 ENSG00000154263 0.859071 0.936069 0.589547 0.259898 0.083258 0.476794 0.526162 0.221172 ENSG00000154265 2.453971 1.480553 9.884425 2.076723 1.118819 5.864268 10.180796 4.383174 ENSG00000154269 0.216739 0.000000 0.854111 0.970053 0.738803 0.521094 4.648410 0.000000 ENSG00000154274 2.980792 0.217999 276.123679 82.820443 34.664053 106.350607 94.854069 14.976808 i = plt.imshow(df2) plt.colorbar(i) plt.show() https://matplotlib.org/api/pyplot_api.html#所有函数的详细参数。 "],["Py3_pratcise_ct.html", "4 Python实战 4.1 Python实战 4.2 Python小技巧", " 4 Python实战 B 站视频课程 （生信宝典知乎号、视频号同步更新）https://space.bilibili.com/362709786/lists/1988354?type=season 4.1 Python实战 4.1.1 ID转换 不同数据库的名字互相转换，比如NCBI的ENTEZ ID转Gene symbol，ENSEMBL编号转ENTREZ ID。 ID转换一般需要2个文件，一个文件是要转换的ID，另外一个文件是ID的对应关系。 以我们的测试文件 (GRCh38.idmap)为例，第一列为ENSEMBLE ID，第二列为Gene symbol，第三列为Entrez ID。 Gene ID Associated Gene Name EntrezGene ID ENSG00000252303 RNU6-280P ENSG00000281771 Y_RNA ENSG00000281876 RP11-399E6.4 101929901 ENSG00000281766 RYBP 23429 ENSG00000281518 FOXO6 100132074 ENSG00000281614 INPP5D 3635 ENSG00000280584 OBP2B 29989 ENSG00000281230 SERTAD4 56256 ENSG00000281917 SLC16A1 6566 待转换的文件 (ensm.id)内容为，期望转换为Gene symbol。 ENSG00000252303 ENSG00000281771 ENSG00000281256 ENSG00000283272 ENSG00000280864 ENSG00000280792 ENSG00000282878 ENSG00000283276 ENSG00000281822 ENSG00000281384 ENSG00000280505 ENSG00000281764 ENSG00000281316 ENSG00000280963 ENSG00000280775 ENSG00000281876 ENSG00000281766 ENSG00000281518 ENSG00000281614 ENSG00000280584 ENSG00000281230 ENSG00000281917 我们怎么做呢？ 直观看起来也比较简单，一个个的去比较、匹配、提取就可以了。 idD = {} for line in open(&quot;data/GRCh38.idmap&quot;): lineL = line.strip().split(&quot;\\t&quot;) ensm_id = lineL[0] symbol = lineL[1] idD[ensm_id] = symbol #-------------------------------- for line in open(&quot;data/ensm.id&quot;): ensm = line.strip() print(ensm,idD[ensm],sep=&quot;: &quot;) ENSG00000252303: RNU6-280P ENSG00000281771: Y_RNA ENSG00000281256: RP11-222G7.2 ENSG00000283272: Clostridiales-1 ENSG00000280864: RP11-654C22.2 ENSG00000280792: RP11-315F22.1 ENSG00000282878: RP11-399E6.1 ENSG00000283276: ABBA01000934.1 ENSG00000281822: RNU1-62P ENSG00000281384: AC093802.1 ENSG00000280505: RP11-654C22.1 ENSG00000281764: RP11-399E6.2 ENSG00000281316: DPPA2P2 ENSG00000280963: SERTAD4-AS1 ENSG00000280775: RNA5SP136 ENSG00000281876: RP11-399E6.4 ENSG00000281766: RYBP ENSG00000281518: FOXO6 ENSG00000281614: INPP5D ENSG00000280584: OBP2B ENSG00000281230: SERTAD4 ENSG00000281917: SLC16A1 # 首先读入GRCh38.idmap文件 # 定义3个变量，文件名，ensembl_id所在列(0-start, source_col), symbol所在列 (1,target_col) # 提前定义的好处是，修改起来会比较方便。 map_file = &quot;data/GRCh38.idmap&quot; source_col = 0 target_col = 1 aDict = {} for line in open(map_file): lineL = line.strip().split(&quot;\\t&quot;) source = lineL[source_col] target = lineL[target_col] aDict[source] = target # 读入ensm.id文件 # 边读边处理 id_file = &quot;data/ensm.id&quot; for line in open(id_file): source_id = line.strip() map_id = aDict.get(source_id, source_id) print(map_id) # 输出到文件 with open(&quot;data/symbol.id&quot;,&quot;w&quot;) as fh: id_file = &quot;data/ensm.id&quot; for line in open(id_file): source_id = line.strip() map_id = aDict.get(source_id, source_id) print(map_id, file=fh) RNU6-280P Y_RNA RP11-222G7.2 Clostridiales-1 RP11-654C22.2 RP11-315F22.1 RP11-399E6.1 ABBA01000934.1 RNU1-62P AC093802.1 RP11-654C22.1 RP11-399E6.2 DPPA2P2 SERTAD4-AS1 RNA5SP136 RP11-399E6.4 RYBP FOXO6 INPP5D OBP2B SERTAD4 SLC16A1 4.1.2 每条染色体基因数目统计 GTF文件存储基因的注释信息。 seqname - name of the chromosome or scaffold; chromosome names can be given with or without the ‘chr’ prefix. Important note: the seqname must be one used within Ensembl, i.e. a standard chromosome name or an Ensembl identifier such as a scaffold ID, without any additional content such as species or assembly. See the example GFF output below. source - name of the program that generated this feature, or the data source (database or project name) feature - feature type name, e.g. Gene, Variation, Similarity start - Start position of the feature, with sequence numbering starting at 1. end - End position of the feature, with sequence numbering starting at 1. score - A floating point value. strand - defined as + (forward) or - (reverse). frame - One of ‘0’, ‘1’ or ‘2’. ‘0’ indicates that the first base of the feature is the first base of a codon, ‘1’ that the second base is the first base of a codon, and so on.. attribute - A semicolon-separated list of tag-value pairs, providing additional information about each feature. chr1 HAVANA gene 11869 14409 . + . gene_id &quot;ENSG00000223972.5&quot;; gene_type &quot;transcribed_unprocessed_pseudogene&quot;; gene_status &quot;KNOWN&quot;; gene_name &quot;DDX11L1&quot;; level 2; havana_gene &quot;OTTHUMG00000000961.2&quot;; chr1 HAVANA gene 14404 29570 . - . gene_id &quot;ENSG00000227232.5&quot;; gene_type &quot;unprocessed_pseudogene&quot;; gene_status &quot;KNOWN&quot;; gene_name &quot;WASH7P&quot;; level 2; havana_gene &quot;OTTHUMG00000000958.1&quot;; chr1 ENSEMBL gene 17369 17436 . - . gene_id &quot;ENSG00000278267.1&quot;; gene_type &quot;miRNA&quot;; gene_status &quot;KNOWN&quot;; gene_name &quot;MIR6859-3&quot;; level 3; 如果统计每条染色体基因数目，只需要读第一列和第三列就可以了。 chr_gene_cntD = {} for line in open(&quot;data/gencode.gene.gtf&quot;): lineL = line.strip().split(&quot;\\t&quot;) chrName = lineL[0] regionType = lineL[2] if (regionType == &quot;gene&quot;): if chrName not in chr_gene_cntD: chr_gene_cntD[chrName] = 1 else: chr_gene_cntD[chrName] += 1 #--------------------------------- for chrName, cnt in list(chr_gene_cntD.items()): print(chrName,&quot;has&quot;,cnt,&#39;genes.&#39;) chr1 has 5397 genes. chr2 has 4150 genes. chr3 has 3163 genes. chr4 has 2633 genes. chr5 has 2993 genes. chr6 has 3001 genes. chr7 has 2980 genes. chr8 has 2444 genes. chr9 has 2350 genes. chr10 has 2306 genes. chr11 has 3381 genes. chr12 has 3047 genes. chr13 has 1383 genes. chr14 has 2289 genes. chr15 has 2247 genes. chr16 has 2597 genes. chr17 has 3111 genes. chr18 has 1206 genes. chr19 has 2997 genes. chr20 has 1436 genes. chr21 has 880 genes. chr22 has 1385 genes. chrX has 2476 genes. chrY has 594 genes. chrM has 37 genes. gtf_file = &quot;data/gencode.gene.gtf&quot; # 一般字典命名，会在行尾加一个大写的D，作为类型代表 chr_gene_cntD = {} for line in open(gtf_file): # 每行按TAB键分成4份 lineL = line.split(&#39;\\t&#39;,3) chr_name = lineL[0] feature = lineL[2] if feature == &quot;gene&quot;: # 如果chr_name已经出现过，则获取其值，然后加1 # 若没出现过，获取0，加1，表示第一次出现 chr_gene_cntD[chr_name] = chr_gene_cntD.get(chr_name,0) + 1 #-------------------------------------- for chr_name, count in chr_gene_cntD.items(): print(chr_name, count) chr1 5397 chr2 4150 chr3 3163 chr4 2633 chr5 2993 chr6 3001 chr7 2980 chr8 2444 chr9 2350 chr10 2306 chr11 3381 chr12 3047 chr13 1383 chr14 2289 chr15 2247 chr16 2597 chr17 3111 chr18 1206 chr19 2997 chr20 1436 chr21 880 chr22 1385 chrX 2476 chrY 594 chrM 37 4.1.3 所有外显子总长度统计 bed12格式 (前3列必须，其它可选) chrom - The name of the chromosome (e.g. chr3, chrY, chr2_random) or scaffold (e.g. scaffold10671). chromStart - The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered 0. chromEnd - The ending position of the feature in the chromosome or scaffold. The chromEnd base is not included in the display of the feature. name - Defines the name of the BED line. This label is displayed to the left of the BED line in the Genome Browser window when the track is open to full display mode or directly to the left of the item in pack mode. score - A score between 0 and 1000. If the track line useScore attribute is set to 1 for this annotation data set, the score value will determine the level of gray in which this feature is displayed (higher numbers = darker gray). This table shows the Genome Browser’s translation of BED score values into shades of gray: thickStart - The starting position at which the feature is drawn thickly (for example, the start codon in gene displays). When there is no thick part, thickStart and thickEnd are usually set to the chromStart position. thickEnd - The ending position at which the feature is drawn thickly (for example the stop codon in gene displays). itemRgb - An RGB value of the form R,G,B (e.g. 255,0,0). If the track line itemRgb attribute is set to “On”, this RBG value will determine the display color of the data contained in this BED line. NOTE: It is recommended that a simple color scheme (eight colors or less) be used with this attribute to avoid overwhelming the color resources of the Genome Browser and your Internet browser. blockCount - The number of blocks (exons) in the BED line. blockSizes - A comma-separated list of the block sizes. The number of items in this list should correspond to blockCount. blockStarts - A comma-separated list of block starts. All of the blockStart positions should be calculated relative to chromStart. The number of items in this list should correspond to blockCount. 基因注释bed12格式 chr1 11868 14409 ENST00000456328.2 0 + 14409 14409 0 3 359,109,1189, 0,744,1352, chr1 12009 13670 ENST00000450305.2 0 + 13670 13670 0 6 48,49,85,78,154,218, 0,169,603,965,1211,1443, chr1 17368 17436 ENST00000619216.1 0 - 17436 17436 0 1 68, 0, chr1 29553 31097 ENST00000473358.1 0 + 31097 31097 0 3 486,104,122, 0,1010,1422, chr1 30266 31109 ENST00000469289.1 0 + 31109 31109 0 2 401,134, 0,709, chr1 30365 30503 ENST00000607096.1 0 + 30503 30503 0 1 138, 0, 第十列是外显子的大小，所有我们只需要把他们加在一起就好了。 Note：实际计算时需要考虑不同转录本之间存在重叠，需要对bed文件预处理，只保留唯一的外显子位置，然后再加和。 exonSizeSum = 0 for line in open(&quot;data/gencode.gene.bed12&quot;): lineL = line.split() exonSize = lineL[10] exonSizeL = exonSize.strip(&#39;,&#39;).split(&#39;,&#39;) for i in exonSizeL: exonSizeSum += int(i) print(exonSizeSum) 291762517 bed12 = &quot;data/gencode.gene.bed12&quot; total_exon_sum = 0 for line in open(bed12): # 从右侧分割为3个元素的列表 # 关注的元素在第二位，索引为1 # 去掉末尾的逗号 lineL = line.rsplit(&quot;\\t&quot;,2) exonSize = lineL[1].strip(&#39;,&#39;) exonSizeL = [int(i) for i in exonSize.split(&#39;,&#39;)] exonSum = sum(exonSizeL) total_exon_sum += exonSum print(&quot;Total exon size is&quot;, total_exon_sum, &quot;nt.&quot;) # 更清晰展示数字大小 print(&quot;Total exon size is&quot;, &quot;{:,}&quot;.format(total_exon_sum), &quot;nt.&quot;) Total exon size is 291762517 nt. Total exon size is 291,762,517 nt. print(&quot;{a[a]}&quot;.format(a={&#39;a&#39;:&quot;world&quot;})) world 4.2 Python小技巧 链似比较 x = 5 print(&quot;1 &lt; x &lt; 10 is&quot;, 1 &lt; x &lt; 10) print(&quot;10 &gt; x &lt;= 9&quot;, 10 &gt; x &lt;= 9) 1 &lt; x &lt; 10 is True 10 &gt; x &lt;= 9 True 解释正则表达式 import re re.compile(&quot;^[a-z]*$&quot;, re.DEBUG) AT AT_BEGINNING MAX_REPEAT 0 MAXREPEAT IN RANGE (97, 122) AT AT_END re.compile(r&#39;^[a-z]*$&#39;, re.UNICODE|re.DEBUG) re.compile(&quot;^[a-z][0-9]+$&quot;, re.DEBUG) AT AT_BEGINNING IN RANGE (97, 122) MAX_REPEAT 1 MAXREPEAT IN RANGE (48, 57) AT AT_END re.compile(r&#39;^[a-z][0-9]+$&#39;, re.UNICODE|re.DEBUG) re.compile(&quot;^[a-z]([0-9]+)$&quot;, re.DEBUG) AT AT_BEGINNING IN RANGE (97, 122) SUBPATTERN 1 0 0 MAX_REPEAT 1 MAXREPEAT IN RANGE (48, 57) AT AT_END re.compile(r&#39;^[a-z]([0-9]+)$&#39;, re.UNICODE|re.DEBUG) enumerate (不再使用len) a = [&#39;s&#39;,&#39;x&#39;,&#39;b&#39;,&#39;d&#39;] # Preferred way for index, item in enumerate(a): print(index,item) print(&quot;\\n&quot;) # Old way for i in range(len(a)): print(i,a[i]) 0 s 1 x 2 b 3 d 0 s 1 x 2 b 3 d 列表解析、字典解析、元组解析 # 获得系列坐标点 a = ((i,j) for i in range(3) for j in range(2)) a &lt;generator object &lt;genexpr&gt; at 0x7fa8d04d7fc0&gt; for i in a: print(i) (0, 0) (0, 1) (1, 0) (1, 1) (2, 0) (2, 1) str1 = &quot;I love sheng xin bao dian&quot; print([i for i in str1.split() if i.endswith(&#39;n&#39;)]) [&#39;xin&#39;, &#39;dian&#39;] a = {i:i*2 for i in range(5)} a {0: 0, 1: 2, 2: 4, 3: 6, 4: 8} [(x, y) for x in range(4) if x % 2 == 1 for y in range(4)] [(1, 0), (1, 1), (1, 2), (1, 3), (3, 0), (3, 1), (3, 2), (3, 3)] 列表索引，反序 a = [1,2,3,4,5] a[::2] [1, 3, 5] a[::-1] [5, 4, 3, 2, 1] for..else;若for循环中未执行break,则else会被执行 found = False for i in range(2,5): if i == 1: found = True break if not found: print(&quot;i was never 1&quot;) i was never 1 for i in range(2,5): if i == 1: break else: print(&quot;i was never 1&quot;) i was never 1 原位替换 a = 5 b = 6 c = 7 a, b = b,a print(&quot;a is&quot;,a) print(&quot;b is&quot;,b) a is 6 b is 5 a, (b,c) = c, (a,b) print(&quot;a is&quot;,a) print(&quot;b is&quot;,b) print(&quot;c is&quot;,c) a is 7 b is 6 c is 5 first, *middle_all, last = (1,2,3,4,5,6) middle_all [2, 3, 4, 5] 集合操作 a = set([&quot;sheng&quot;, &quot;xin&quot;, &quot;bao&quot;,&quot;dian&quot;,&quot;best&quot;,&quot;tutotials&quot;]) b = set([&quot;hong&quot;, &quot;ji&quot;, &quot;yin&quot;,&quot;zu&quot;,&quot;best&quot;,&quot;tutotials&quot;]) a | b # union {&#39;bao&#39;, &#39;best&#39;, &#39;dian&#39;, &#39;hong&#39;, &#39;ji&#39;, &#39;sheng&#39;, &#39;tutotials&#39;, &#39;xin&#39;, &#39;yin&#39;, &#39;zu&#39;} a &amp; b # intersection {&#39;best&#39;, &#39;tutotials&#39;} a ^ b # Symmetric Difference {&#39;bao&#39;, &#39;dian&#39;, &#39;hong&#39;, &#39;ji&#39;, &#39;sheng&#39;, &#39;xin&#39;, &#39;yin&#39;, &#39;zu&#39;} Negative round print(&quot;round整数:&quot;,str(round(1234.5678, -2))) print(&quot;round小数:&quot;,str(round(1234.5678, 2))) round整数: 1200.0 round小数: 1234.57 多行字符串的嵌套 # \\可以，但是第二行需要起头 system_command = &quot;s-plot pheatmap -f matrix \\ -t heatmap -a TRUE&quot; print(system_command) s-plot pheatmap -f matrix -t heatmap -a TRUE # 字符串中包含换行符 # 切第二行要起头，不然会有较多空格 system_command = &quot;&quot;&quot;s-plot pheatmap -f matrix -t heatmap -a TRUE&quot;&quot;&quot; print(system_command) print(system_command.replace(&#39;\\n&#39;, &#39; &#39;)) s-plot pheatmap -f matrix -t heatmap -a TRUE s-plot pheatmap -f matrix -t heatmap -a TRUE # 类元组的写法，既可以跨行，又可以自由格式 # 需要注意2点 # 类元组，无逗号 # 字符串连接时不会自动加空格，空格需要保存在字符串里面 system_command = (&quot;s-plot pheatmap -f matrix &quot; &quot;-t heatmap -a TRUE&quot;) print(system_command) s-plot pheatmap -f matrix -t heatmap -a TRUE # 多一步join； system_command = [&quot;s-plot pheatmap -f matrix&quot;, &quot;-t heatmap -a TRUE&quot;] print(&#39; &#39;.join(system_command)) s-plot pheatmap -f matrix -t heatmap -a TRUE 矩阵转置 a = [(1,2), (3,4), (5,6)] b = zip(*a) for i in b: print(i) (1, 3, 5) (2, 4, 6) zip转换两个列表为字典 keyL = [1,2,3] valueL = [&#39;a&#39;,&#39;b&#39;,&#39;v&#39;] for i ,j in zip(keyL, valueL): print(i,j) 1 a 2 b 3 v import pprint pprint.pprint(dict(zip(keyL, valueL))) {1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;v&#39;} dict([(i,j) for i ,j in zip(keyL, valueL)]) {1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;v&#39;} 重复 &#39;xyz&#39; * 3 &#39;xyzxyzxyz&#39; 3 * &#39;xyz&#39; &#39;xyzxyzxyz&#39; [1,2] * 3 [1, 2, 1, 2, 1, 2] 启动网络服务器，用于文件预览或传输 # run in commang line # python -m http.server 8000 Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... sum的另一用法，二维数组秒变1维 aList = [[1, 2, 3], [4, 5], [6], [7, 8, 9]] sum(aList, []) [1, 2, 3, 4, 5, 6, 7, 8, 9] 打开一个关于Python漫画的网站 #import antigravity print(&#39;\\n&#39;.join([&#39;&#39;.join([(&#39;Love&#39;[(x-y) % len(&#39;Love&#39;)] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 &lt;= 0 else &#39; &#39;) for x in range(-30, 30)]) for y in range(30, -30, -1)])) veLoveLov veLoveLov eLoveLoveLoveLove eLoveLoveLoveLove veLoveLoveLoveLoveLoveLoveLoveLoveLoveLov veLoveLoveLoveLoveLoveLoveLoveLoveLoveLoveL veLoveLoveLoveLoveLoveLoveLoveLoveLoveLoveLov eLoveLoveLoveLoveLoveLoveLoveLoveLoveLoveLove LoveLoveLoveLoveLoveLoveLoveLoveLoveLoveLoveL oveLoveLoveLoveLoveLoveLoveLoveLoveLoveLoveLo veLoveLoveLoveLoveLoveLoveLoveLoveLoveLoveLov eLoveLoveLoveLoveLoveLoveLoveLoveLoveLoveLove oveLoveLoveLoveLoveLoveLoveLoveLoveLoveLove eLoveLoveLoveLoveLoveLoveLoveLoveLoveLove LoveLoveLoveLoveLoveLoveLoveLoveLoveLoveL eLoveLoveLoveLoveLoveLoveLoveLoveLove oveLoveLoveLoveLoveLoveLoveLoveLove eLoveLoveLoveLoveLoveLoveLoveLove veLoveLoveLoveLoveLoveLoveLov oveLoveLoveLoveLoveLoveLo LoveLoveLoveLoveLoveL LoveLoveLoveLov LoveLoveL Lov v 曼德勃罗集合 print(&#39;\\n&#39;.join([&#39;&#39;.join([&#39;*&#39;if abs((lambda a:lambda z,c,n:a(a,z,c,n))(lambda s,z,c,n:z if n==0else s(s,z*z+c,c,n-1))(0,0.02*x+0.05j*y,40))&lt;2 else&#39; &#39;for x in range(-80,20)])for y in range(-20,20)])) * ** *********** ************ ********* * * ************ * * ****** * *************************** * *************************************** ***** ******************************************* *** ******************************************** * ************************************************** ******************************************************* * * ***************************************************** **** ******* * ******************************************************* ***************** ******************************************************* *********************** ********************************************************* *********************** ******************************************************** **** ******************************************************************************** ********************************************************************************************* **** ******************************************************************************** *********************** ******************************************************** *********************** ********************************************************* ***************** ******************************************************* **** ******* * ******************************************************* * * ***************************************************** ******************************************************* ************************************************** *** ******************************************** * ******************************************* *************************************** ***** ****** * *************************** * * * ************ * * ********* ************ *********** ** python打印九九乘法表 print(&#39;\\n&#39;.join([&#39; &#39;.join([&#39;%s*%s=%-2s&#39; % (y,x,x*y) for y in range(1,x+1)]) for x in range(1,10)])) 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 map, filter # 过滤大于4的元素 a = [3,4,5] [i for i in a if i&lt;4] [3] list(filter(lambda x: x&lt;4, a)) [5] # 每个元素加2 [i+2 for i in a] [5, 6, 7] map(lambda x: x+2, a) &lt;map at 0x7fa8d0502358&gt; list(map(lambda x: x+2, a)) [5, 6, 7] 算2的1000次方的各位数之和 sum(map(int, str(2**1000))) 1366 "],["py3_pandas_ct.html", "5 Pandas 学习教程 5.1 What is pandas 5.2 Pandas读取文件 5.3 Pandas写入文件 5.4 PANDAS矩阵的小应用 5.5 Seaborn绘图", " 5 Pandas 学习教程 陈同 chentong_biology@163.com B 站视频课程 （生信宝典知乎号、视频号同步更新）https://space.bilibili.com/362709786/lists/1988354?type=season 5.1 What is pandas Pandas是python中用于处理矩阵样数据的功能强大的包，提供了R中的dataframe和vector的操作，使得我们在使用python时，也可以方便、简单、快捷、高效地进行矩阵数据处理。 具体介绍详见http://pandas.pydata.org/。 A fast and efficient DataFrame object for data manipulation with integrated indexing; Tools for reading and writing data between in-memory data structures and different formats: CSV and text files, Microsoft Excel, SQL databases, and the fast HDF5 format; Intelligent data alignment and integrated handling of missing data: gain automatic label-based alignment in computations and easily manipulate messy data into an orderly form; Flexible reshaping and pivoting of data sets; Intelligent label-based slicing, fancy indexing, and subsetting of large data sets; Columns can be inserted and deleted from data structures for size mutability; Aggregating or transforming data with a powerful group by engine allowing split-apply-combine operations on data sets; High performance merging and joining of data sets; Hierarchical axis indexing provides an intuitive way of working with high-dimensional data in a lower-dimensional data structure; Time series-functionality: date range generation and frequency conversion, moving window statistics, moving window linear regressions, date shifting and lagging. Even create domain-specific time offsets and join time series without losing data; Highly optimized for performance, with critical code paths written in Cython or C. Python with pandas is in use in a wide variety of academic and commercial domains, including Finance, Neuroscience, Economics, Statistics, Advertising, Web Analytics, and more. %matplotlib inline #import plotly #plotly.offline.init_notebook_mode() import matplotlib matplotlib.style.use(&#39;ggplot&#39;) import numpy as np import matplotlib.pyplot as plt import pandas as pd import os from glob import glob 5.2 Pandas读取文件 5.2.1 获取目标文件 dir_1 = &quot;py_data/&quot; glob(dir_1+&#39;*&#39;) [&#39;py_data/ENCFF060LPA.tsv&#39;, &#39;py_data/ENCFF262OBL.tsv&#39;, &#39;py_data/ENCFF289HGQ.tsv&#39;, &#39;py_data/ENCFF673KYR.tsv&#39;, &#39;py_data/gencode.v24.ENS2SYN&#39;, &#39;py_data/meta.tsv&#39;, &#39;py_data/gencode.gene.gtf&#39;, &#39;py_data/gencode.gene.bed12&#39;, &#39;py_data/ensm.id&#39;, &#39;py_data/GRCh38.idmap&#39;] 5.2.2 查看目标文件内容和格式 Ipython中可以通过在Linux命令前加!调用系统命令，更多使用见 http://ipython.org/ipython-doc/3/interactive/reference.html#system-shell-access. !head -n 4 py_data/gencode.v24.ENS2SYN gene_id gene_symbol ENSG00000001460.17 STPG1 ENSG00000001461.16 NIPAL3 ENSG00000000938.12 FGR !head -n 4 py_data/ENCFF060LPA.tsv gene_id transcript_id(s) length effective_length expected_count TPM FPKM ENSG00000000003.14 ENST00000373020.8,ENST00000494424.1,ENST00000496771.5,ENST00000612152.4,ENST00000614008.4 2240.53 2020.49 5126.00 6.64 18.24 ENSG00000000005.5 ENST00000373031.4,ENST00000485971.1 940.50 720.47 0.00 0.00 0.00 ENSG00000000419.12 ENST00000371582.8,ENST00000371584.8,ENST00000371588.9,ENST00000413082.1,ENST00000466152.5,ENST00000494752.1 1072.03 851.99 3222.00 9.91 27.19 5.2.3 读取两列文件 ens2syn_file = dir_1+&quot;/gencode.v24.ENS2SYN&quot; # pandas中的计数都是从0开始的 # header=0: 指定第一行包含列的名字 # index_col=0: 指定第一列为行的名字 ens2syn = pd.read_table(ens2syn_file, header=0, index_col=0) ens2syn.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000001460.17 STPG1 ENSG00000001461.16 NIPAL3 ENSG00000000938.12 FGR ENSG00000004455.16 AK2 ENSG00000000460.16 C1orf112 5.2.4 数据表的索引 * 数值索引和布尔值索引是按行选取 * 字符串索引是按列选取 * 行和列是等效的，应用于行的选取函数也可应用于列，反之亦然 5.2.4.1 按行选取数据 ens2syn[:3] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000001460.17 STPG1 ENSG00000001461.16 NIPAL3 ENSG00000000938.12 FGR 5.2.4.2 取出索引中包含特定值的行 ens2syn[ens2syn.index==&quot;ENSG00000001460.17&quot;] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000001460.17 STPG1 5.2.4.3 取出某列包含特定值列表的行 ens2syn[ens2syn[&#39;gene_symbol&#39;].isin([&#39;STPG1&#39;,&#39;FGR&#39;])] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000001460.17 STPG1 ENSG00000000938.12 FGR 5.2.4.4 使用正则表达式选取符合要求的行 # head: 只展示部分数据 ens2syn[ens2syn.index.str.contains(r&#39;ENSG000000014&#39;)].head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000001460.17 STPG1 ENSG00000001461.16 NIPAL3 ENSG00000001497.16 LAS1L 5.2.5 读取多列文件 gzip, bzip压缩的文件也可以直接读取，但是需要保证文件后缀的正确。 read_table默认参数可以自动检测文件的格式，根据文件的后缀 ‘.gz’, ‘.bz2’, ‘.zip’, or ’xz’分别使用 gzip, bz2, zip or xz读取。 tsvL = glob(dir_1+&#39;ENC*.tsv&#39;) tsvL [&#39;py_data/ENCFF060LPA.tsv&#39;, &#39;py_data/ENCFF262OBL.tsv&#39;, &#39;py_data/ENCFF289HGQ.tsv&#39;, &#39;py_data/ENCFF673KYR.tsv&#39;] index = 0 tsvFile = tsvL[index] expr = pd.read_table(tsvFile, header=0, index_col=0) expr.head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } transcript_id(s) length effective_length expected_count TPM FPKM gene_id ENSG00000000003.14 ENST00000373020.8,ENST00000494424.1,ENST000004... 2240.53 2020.49 5126.0 6.64 18.24 ENSG00000000005.5 ENST00000373031.4,ENST00000485971.1 940.50 720.47 0.0 0.00 0.00 ENSG00000000419.12 ENST00000371582.8,ENST00000371584.8,ENST000003... 1072.03 851.99 3222.0 9.91 27.19 5.2.6 选取多列数据 列的输出顺序与给定的列名字的顺序一致 expr[[&#39;FPKM&#39;,&#39;TPM&#39;]].head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } FPKM TPM gene_id ENSG00000000003.14 18.24 6.64 ENSG00000000005.5 0.00 0.00 ENSG00000000419.12 27.19 9.91 5.2.7 重命名列名字 从Dataframe中只选取一列时，数据框会被转换成Series，因此需要使用pd.loc[:,[column_name]](虽然内部的方括号内只有一个值，但写法是必须的)索引。 tsvFile os.path.split(tsvFile)[-1][:-4] &#39;ENCFF060LPA&#39; # 因为要把多个文件的同一类型表达值合并到一个文件，我们使用文件名作为列的名字 name = os.path.split(tsvFile)[-1][:-4] print(name) expr_tpm = expr.loc[:,[&#39;TPM&#39;]] # 取出所有的行和名字为TPM的列 #expr_tpm.head() # 给列重命名 expr_tpm.columns=[name] expr_tpm[:3] ENCFF060LPA .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA gene_id ENSG00000000003.14 6.64 ENSG00000000005.5 0.00 ENSG00000000419.12 9.91 5.2.8 合并矩阵 5.2.8.1 定义函数简化文件读取 # 为了读取多个文件，定义一个函数简化操作 def readExpr_1(tsvFileL, typeL=[&#39;TPM&#39;,&#39;FPKM&#39;]): &#39;&#39;&#39; tsvFileL: lists of files waiting for reading resultD: a dictionary to save data matrix {&#39;TPM&#39;:[mat1, mat2,...] &#39;FPKM&#39;:[mat1, mat2, ...]} typeL; list of names for columns to be extracted &#39;&#39;&#39; resultD = {} for _type in typeL: resultD[_type] = [] for tsvFile in tsvFileL: expr = pd.read_table(tsvFile, header=0, index_col=0) name = os.path.split(tsvFile)[-1][:-4] #this option is very arbitary for _type in typeL: # add _ to type to avoid override Python inner function `type` expr_type = expr.loc[:,[_type]] expr_type.columns = [name] resultD[_type].append(expr_type) return resultD #----------------------------------------------------- exprD = readExpr_1(tsvL) TPM_mat = exprD[&#39;TPM&#39;] FPKM_mat = exprD[&#39;FPKM&#39;] 5.2.8.2 使用pd.merge合并矩阵示例 先从刚才读取的矩阵中选出2个测试下pandas中的矩阵合并方法和效果 # 选取第一个矩阵 _idL = [&#39;ENSG00000000003.14&#39;, &#39;ENSG00000000005.5&#39;,&#39;ENSG00000000419.12&#39;, &#39;ENSG00000000457.13&#39;] mat1 = TPM_mat[0] mat1 = mat1[mat1.index.isin(_idL)] mat1 .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA gene_id ENSG00000000003.14 6.64 ENSG00000000005.5 0.00 ENSG00000000419.12 9.91 ENSG00000000457.13 0.86 # 选取第二个矩阵 _idL = [&#39;ENSG00000001561.6&#39;,&#39;ENSG00000000003.14&#39;, &#39;ENSG00000000419.12&#39;,&#39;ENSG00000001036.13&#39;] mat2 = TPM_mat[1] mat2 = mat2[mat2.index.isin(_idL)] mat2 .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF262OBL gene_id ENSG00000000003.14 17.13 ENSG00000000419.12 18.86 ENSG00000001036.13 10.34 ENSG00000001561.6 2.47 基于索引(index)的合并 * outer: 合并所有的索引，缺失值填充NA * inner：保留共有的索引 * left：使用第一个矩阵的索引 * right：使用第二个矩阵的索引 pd.merge(mat1, mat2, left_index=True, right_index=True, how=&quot;outer&quot;) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL gene_id ENSG00000000003.14 6.64 17.13 ENSG00000000005.5 0.00 NaN ENSG00000000419.12 9.91 18.86 ENSG00000000457.13 0.86 NaN ENSG00000001036.13 NaN 10.34 ENSG00000001561.6 NaN 2.47 pd.merge(mat1, mat2, left_index=True, right_index=True, how=&quot;inner&quot;) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL gene_id ENSG00000000003.14 6.64 17.13 ENSG00000000419.12 9.91 18.86 pd.merge(mat1, mat2, left_index=True, right_index=True, how=&quot;left&quot;) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL gene_id ENSG00000000003.14 6.64 17.13 ENSG00000000005.5 0.00 NaN ENSG00000000419.12 9.91 18.86 ENSG00000000457.13 0.86 NaN 5.2.8.3 使用pd.concat合并矩阵示例 对于较多的数据表合并操作时，concat比merge要简单快速很多。 pd.concat([mat1, mat2], axis=1) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL ENSG00000000003.14 6.64 17.13 ENSG00000000005.5 0.00 NaN ENSG00000000419.12 9.91 18.86 ENSG00000000457.13 0.86 NaN ENSG00000001036.13 NaN 10.34 ENSG00000001561.6 NaN 2.47 pd.concat([mat1, mat2], axis=1, join=&quot;inner&quot;) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL gene_id ENSG00000000003.14 6.64 17.13 ENSG00000000419.12 9.91 18.86 5.2.8.4 使用pd.join合并矩阵示例 mat3 = mat1.join(mat2, how=&quot;outer&quot;) mat3 .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL gene_id ENSG00000000003.14 6.64 17.13 ENSG00000000005.5 0.00 NaN ENSG00000000419.12 9.91 18.86 ENSG00000000457.13 0.86 NaN ENSG00000001036.13 NaN 10.34 ENSG00000001561.6 NaN 2.47 替换NA值为0 mat3 = mat3.fillna(0) mat3 .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL gene_id ENSG00000000003.14 6.64 17.13 ENSG00000000005.5 0.00 0.00 ENSG00000000419.12 9.91 18.86 ENSG00000000457.13 0.86 0.00 ENSG00000001036.13 0.00 10.34 ENSG00000001561.6 0.00 2.47 去除所有值都为0的行 #Both works well here #mat3[(mat3&gt;0).any(axis=1)] mat3.loc[(mat3&gt;0).any(axis=1)] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL gene_id ENSG00000000003.14 6.64 17.13 ENSG00000000419.12 9.91 18.86 ENSG00000000457.13 0.86 0.00 ENSG00000001036.13 0.00 10.34 ENSG00000001561.6 0.00 2.47 5.2.8.5 测试三种方法使用的内存和速度比较 速度：concat&gt;join&gt;&gt;merge 内存：相当 # 不错的reduce教程 from functools import reduce %timeit test_merge = reduce(lambda left,right: pd.merge(left,right,left_index=True,right_index=True,how=&#39;outer&#39;), TPM_mat) 3.04 ms ± 52.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) %timeit test_merge = pd.concat(TPM_mat, axis=1) 1.29 ms ± 30.5 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) %timeit TPM_mat[0].join(TPM_mat[1:], how=&quot;outer&quot;) 1.31 ms ± 11.2 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) # 首先安装memory_profiler,加载插件 %load_ext memory_profiler %memit test_merge = reduce(lambda left,right: pd.merge(left,right,left_index=True,right_index=True,how=&#39;outer&#39;), TPM_mat) peak memory: 101.27 MiB, increment: 0.02 MiB %memit test_merge = pd.concat(TPM_mat, axis=1) peak memory: 101.28 MiB, increment: 0.00 MiB %memit TPM_mat[0].join(TPM_mat[1:], how=&quot;outer&quot;) peak memory: 101.28 MiB, increment: 0.00 MiB 5.2.8.6 重写函数完成文件的读写和矩阵的合并 # 读取多个文件，并且合并矩阵，定义一个函数简化操作 def concatExpr(tsvFileL, typeL=[&#39;TPM&#39;,&#39;FPKM&#39;]): &#39;&#39;&#39; tsvFileL: lists of files waiting for reading resultD: a dictionary to save data matrix {&#39;TPM&#39;:[mat1, mat2,...] &#39;FPKM&#39;:[mat1, mat2, ...]} typeL; list of names for columns to be extracted &#39;&#39;&#39; resultD = {} for _type in typeL: resultD[_type] = [] for tsvFile in tsvFileL: expr = pd.read_table(tsvFile, header=0, index_col=0) name = os.path.split(tsvFile)[-1][:-4] #this options is very arbitary for _type in typeL: # add _ to type to avoid override Python inner function `type` expr_type = expr.loc[:,[_type]] expr_type.columns = [name] resultD[_type].append(expr_type) #------------------------------------------- mergeD = {} for _type in typeL: mergeM = pd.concat(resultD[_type], axis=1) mergeM = mergeM.fillna(0) # Substitute all NA with 0 mergeM = mergeM.loc[(mergeM&gt;0).any(axis=1)] # Delete aoo zero rows. mergeD[_type] = mergeM return mergeD #----------------------------------------------------- typeL = [&#39;TPM&#39;,&#39;FPKM&#39;] exprD = concatExpr(tsvL, typeL) TPM_mat = exprD[&#39;TPM&#39;] FPKM_mat = exprD[&#39;FPKM&#39;] TPM_mat.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL ENCFF289HGQ ENCFF673KYR gene_id ENSG00000000003.14 6.64 17.13 1.03 2.42 ENSG00000000419.12 9.91 18.86 1.45 1.80 ENSG00000000457.13 0.86 2.48 0.24 0.38 ENSG00000000460.16 1.51 5.36 0.26 0.16 ENSG00000000938.12 0.01 0.05 0.00 0.00 5.2.9 矩阵数据提取 只保留表达矩阵中存储的基因的ID和Symbol对照表 # 回顾下数据格式 ens2syn.head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000001460.17 STPG1 ENSG00000001461.16 NIPAL3 ENSG00000000938.12 FGR ens2syn.shape (48, 1) ens2syn = ens2syn[ens2syn.index.isin(TPM_mat.index)] ens2syn.shape (48, 1) ens2syn.head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000001460.17 STPG1 ENSG00000001461.16 NIPAL3 ENSG00000000938.12 FGR 5.2.10 读取META data文件 meta = &quot;data/meta.tsv&quot; metaM = pd.read_table(meta, header=0, index_col=0) # 重名了列的名字 oriColnames = metaM.columns.values nameD = dict([(i,i.replace(&#39; &#39;,&#39;_&#39;)) for i in oriColnames]) metaM.rename(columns=nameD, inplace=True) metaM.head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Biosample_term_id Biosample_term_name Biosample_type Biosample_life_stage Biosample_sex Biosample_organism Biosample_treatments Biosample_subcellular_fraction_term_name Biosample_phase Biosample_synchronization_stage Biosample_Age File accession ENCFF673KYR CL:0000650 mesangial cell primary cell unknown, fetal unknown, female Homo sapiens NaN NaN NaN NaN NaN ENCFF262OBL CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens NaN NaN NaN NaN 52 year ENCFF060LPA CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens NaN NaN NaN NaN 23 year 5.2.10.1 只保留前面提到的4个样品的数据 sampleL = TPM_mat.columns.values metaM = metaM[metaM.index.isin(sampleL)] # 同时索引行和列 metaM.iloc[:4,:5] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Biosample_term_id Biosample_term_name Biosample_type Biosample_life_stage Biosample_sex File accession ENCFF673KYR CL:0000650 mesangial cell primary cell unknown, fetal unknown, female ENCFF262OBL CL:1001568 pulmonary artery endothelial cell primary cell adult male ENCFF060LPA CL:1001568 pulmonary artery endothelial cell primary cell adult male ENCFF289HGQ CL:0002558 fibroblast of villous mesenchyme primary cell newborn male, female 5.2.10.2 提取目标列信息 # 假如只提取`Biosample`开头的列 #meta_colL = [&#39;Biosample term id&#39;, &#39;Biosample term name&#39;] # Extract columns matching specific patterns # Both works well, filter is more simple #metaM.loc[:,metaM.columns.str.contains(r&#39;^Biosample&#39;)] metaM = metaM.filter(regex=(&quot;^Biosample&quot;)) metaM .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Biosample_term_id Biosample_term_name Biosample_type Biosample_life_stage Biosample_sex Biosample_organism Biosample_treatments Biosample_subcellular_fraction_term_name Biosample_phase Biosample_synchronization_stage Biosample_Age File accession ENCFF673KYR CL:0000650 mesangial cell primary cell unknown, fetal unknown, female Homo sapiens NaN NaN NaN NaN NaN ENCFF262OBL CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens NaN NaN NaN NaN 52 year ENCFF060LPA CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens NaN NaN NaN NaN 23 year ENCFF289HGQ CL:0002558 fibroblast of villous mesenchyme primary cell newborn male, female Homo sapiens NaN NaN NaN NaN NaN metaM.fillna(&#39;&#39;) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Biosample_term_id Biosample_term_name Biosample_type Biosample_life_stage Biosample_sex Biosample_organism Biosample_treatments Biosample_subcellular_fraction_term_name Biosample_phase Biosample_synchronization_stage Biosample_Age File accession ENCFF673KYR CL:0000650 mesangial cell primary cell unknown, fetal unknown, female Homo sapiens ENCFF262OBL CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens 52 year ENCFF060LPA CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens 23 year ENCFF289HGQ CL:0002558 fibroblast of villous mesenchyme primary cell newborn male, female Homo sapiens 5.3 Pandas写入文件 5.3.1 写入文本文件 metaM.to_csv(&quot;pandas_data/meta2.tsv&quot;, sep=&quot;\\t&quot;) ens2syn.to_csv(&quot;pandas_data/gencode.v24.ENS2SYN&quot;, sep=&quot;\\t&quot;) TPM_mat.to_csv(&quot;pandas_data/TPM&quot;, sep=&#39;\\t&#39;, float_format=&quot;%.2f&quot;) 5.4 PANDAS矩阵的小应用 利用上面的矩阵操作，选取这两个基因相关的信息并绘制表达谱 targetL = [&#39;KRIT1&#39;,&#39;AK2&#39;] Gene_symbol转换为Gene_id ensID = ens2syn[ens2syn[&quot;gene_symbol&quot;].isin(targetL)] ensID .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_symbol gene_id ENSG00000004455.16 AK2 ENSG00000001631.14 KRIT1 提取目标基因的表达 targetExpr = TPM_mat[TPM_mat.index.isin(ensID.index)] targetExpr .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL ENCFF289HGQ ENCFF673KYR gene_id ENSG00000001631.14 6.21 13.36 1.15 1.37 ENSG00000004455.16 15.57 37.62 2.31 8.95 重命名矩阵的索引 ensID_dict = ensID.to_dict() ensID_dict {&#39;gene_symbol&#39;: {&#39;ENSG00000001631.14&#39;: &#39;KRIT1&#39;, &#39;ENSG00000004455.16&#39;: &#39;AK2&#39;}} targetExpr = targetExpr.rename(index=ensID_dict[&#39;gene_symbol&#39;]) targetExpr .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL ENCFF289HGQ ENCFF673KYR gene_id KRIT1 6.21 13.36 1.15 1.37 AK2 15.57 37.62 2.31 8.95 转置矩阵以增加META信息 targetExpr_t = targetExpr.T targetExpr_t .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_id KRIT1 AK2 ENCFF060LPA 6.21 15.57 ENCFF262OBL 13.36 37.62 ENCFF289HGQ 1.15 2.31 ENCFF673KYR 1.37 8.95 从meta矩阵中提取4列信息 metaM.head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Biosample_term_id Biosample_term_name Biosample_type Biosample_life_stage Biosample_sex Biosample_organism Biosample_treatments Biosample_subcellular_fraction_term_name Biosample_phase Biosample_synchronization_stage Biosample_Age File accession ENCFF673KYR CL:0000650 mesangial cell primary cell unknown, fetal unknown, female Homo sapiens NaN NaN NaN NaN NaN ENCFF262OBL CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens NaN NaN NaN NaN 52 year ENCFF060LPA CL:1001568 pulmonary artery endothelial cell primary cell adult male Homo sapiens NaN NaN NaN NaN 23 year meta_type = [&quot;Biosample_term_name&quot;,&quot;Biosample_type&quot;, &quot;Biosample_life_stage&quot;, &quot;Biosample_sex&quot;] meta = metaM[meta_type] meta .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } Biosample_term_name Biosample_type Biosample_life_stage Biosample_sex File accession ENCFF673KYR mesangial cell primary cell unknown, fetal unknown, female ENCFF262OBL pulmonary artery endothelial cell primary cell adult male ENCFF060LPA pulmonary artery endothelial cell primary cell adult male ENCFF289HGQ fibroblast of villous mesenchyme primary cell newborn male, female target_expr_meta = targetExpr_t.join(meta, how=&quot;left&quot;) target_expr_meta .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } KRIT1 AK2 Biosample_term_name Biosample_type Biosample_life_stage Biosample_sex ENCFF060LPA 6.21 15.57 pulmonary artery endothelial cell primary cell adult male ENCFF262OBL 13.36 37.62 pulmonary artery endothelial cell primary cell adult male ENCFF289HGQ 1.15 2.31 fibroblast of villous mesenchyme primary cell newborn male, female ENCFF673KYR 1.37 8.95 mesangial cell primary cell unknown, fetal unknown, female target_expr_meta.drop([&quot;Biosample_term_name&quot;, &quot;Biosample_type&quot;], axis=1) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } KRIT1 AK2 Biosample_life_stage Biosample_sex ENCFF060LPA 6.21 15.57 adult male ENCFF262OBL 13.36 37.62 adult male ENCFF289HGQ 1.15 2.31 newborn male, female ENCFF673KYR 1.37 8.95 unknown, fetal unknown, female 绘制散点图 target_expr_meta.plot.scatter(x=&#39;KRIT1&#39;, y=&#39;AK2&#39;) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fbf95322390&gt; 绘制箱线图 a = target_expr_meta.boxplot([&quot;KRIT1&quot;, &quot;AK2&quot;]) 绘制每个样品的基因表达分布 ax = TPM_mat.boxplot(list(TPM_mat.columns)) ax.set_ylim(0,100) ax.set_ylabel(&quot;TPM&quot;) ax.set_xlabel(&quot;Samples&quot;) ax.set_title(&quot;Gene expression distribution for all samples&quot;) Text(0.5,1,&#39;Gene expression distribution for all samples&#39;) 更多坐标轴调整见 https://matplotlib.org/api/axes_api.html#axis-labels-title-and-legend 5.5 Seaborn绘图 Seaborn是基于matplotlib的python可视化库，提供更高级的接口和更好的定制性，支持numpy和pandas数据结构，和scipy和statsmodels的统计计算。 # 导入seaborn库，并给予一个更简短的名字，方便后续引用 import seaborn as sns TPM_mat.head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL ENCFF289HGQ ENCFF673KYR gene_id ENSG00000000003.14 6.64 17.13 1.03 2.42 ENSG00000000419.12 9.91 18.86 1.45 1.80 ENSG00000000457.13 0.86 2.48 0.24 0.38 Pandas绘图 TPM_mat.plot(kind=&quot;scatter&quot;, x=&quot;ENCFF060LPA&quot;, y=&quot;ENCFF262OBL&quot;) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fbf84af0a20&gt; Seaborn绘图 (还可以直接显示直方图，计算相关性) sns.jointplot(x=&quot;ENCFF060LPA&quot;, y=&quot;ENCFF262OBL&quot;, data=TPM_mat, size=4) &lt;seaborn.axisgrid.JointGrid at 0x7fbf9531a1d0&gt; sp = sns.heatmap(TPM_mat) TPM_mat_cor = TPM_mat.corr() sns.heatmap(TPM_mat_cor) &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fbf8494a2b0&gt; ax = TPM_mat.boxplot(list(TPM_mat.columns)) ax.set_ylim(0,100) ax.set_ylabel(&quot;TPM&quot;) ax.set_xlabel(&quot;Samples&quot;) ax.set_title(&quot;Gene expression distribution for all samples&quot;) Text(0.5,1,&#39;Gene expression distribution for all samples&#39;) TPM_mat[&#39;gene_id&#39;] = TPM_mat.index TPM_mat.head(4) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } ENCFF060LPA ENCFF262OBL ENCFF289HGQ ENCFF673KYR gene_id gene_id ENSG00000000003.14 6.64 17.13 1.03 2.42 ENSG00000000003.14 ENSG00000000419.12 9.91 18.86 1.45 1.80 ENSG00000000419.12 ENSG00000000457.13 0.86 2.48 0.24 0.38 ENSG00000000457.13 ENSG00000000460.16 1.51 5.36 0.26 0.16 ENSG00000000460.16 #http://pandas.pydata.org/pandas-docs/stable/generated/pandas.wide_to_long.html TPM_melt = pd.melt(TPM_mat, id_vars=[&#39;gene_id&#39;]) TPM_melt.head(3) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } gene_id variable value 0 ENSG00000000003.14 ENCFF060LPA 6.64 1 ENSG00000000419.12 ENCFF060LPA 9.91 2 ENSG00000000457.13 ENCFF060LPA 0.86 ax = sns.boxplot(x=&quot;variable&quot;, y=&quot;value&quot;, data=TPM_melt) "],["numpy_scipy.html", "6 Python科学计算 6.1 NumPy 6.2 SciPy", " 6 Python科学计算 6.1 NumPy 6.1.1 NumPy数组 import numpy as np import numpy.random as rand import matplotlib.pyplot as plt ## Numpy克服了Python中list速度慢的缺点，创建了新数据类型ndarray ## ndarray的每列元素一般是相同类型的，是浮点数、整型或字符串，这点和list不同 ## 下面的例子测试对比了ndarray和list速度上的区别 ## 首先建立一个0...10^7-1的10^7个元素的数组 arr=np.arange(1e7) ## 将ndarray转换为list larr=arr.tolist() ## 工具函数，模拟ndarray把list的每个元素乘以一个标量的运算 def list_times(alist, scalar): for i, val in enumerate(alist): alist[i]=val*scalar return alist ## 比较ndarray和list每个元素乘以一个标量的运行时间 ## 在我的电脑上，ndarray乘以一个标量的运行时间要比list快约33倍 %timeit arr*1.1 %timeit list_times(larr,1.1) 37 ms ± 1.49 ms per loop (mean ± std. dev. of 7 runs, 10 loops each) 1.22 s ± 41.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) ## 两个2维ndarray相乘是对应元素相乘，而两个matrix相乘是进行矩阵乘法 ## matrix只有2维，以下代码运行会出错：shape too large to be a matrix arr=np.zeros((3,3,3)) mat=np.matrix(arr) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-2-667d2452a8e0&gt; in &lt;module&gt;() 2 # matrix只有2维，以下代码运行会出错 3 arr=np.zeros((3,3,3)) ----&gt; 4 mat=np.matrix(arr) ~/anaconda3/lib/python3.6/site-packages/numpy/matrixlib/defmatrix.py in __new__(subtype, data, dtype, copy) 224 else: 225 intype = N.dtype(dtype) --&gt; 226 new = data.view(subtype) 227 if intype != data.dtype: 228 return new.astype(intype) ~/anaconda3/lib/python3.6/site-packages/numpy/matrixlib/defmatrix.py in __array_finalize__(self, obj) 269 return 270 elif (ndim &gt; 2): --&gt; 271 raise ValueError(&quot;shape too large to be a matrix.&quot;) 272 else: 273 newshape = self.shape ValueError: shape too large to be a matrix. 6.1.1.1 创建数组和定义数据类型 ## 在NumPy中，创建数组有多种方法 ## 首先创建一个list，然后用np.array()方法把它包裹起来 alist=[1,2,3] arr=np.array(alist) arr array([1, 2, 3]) ## 创建一个5个元素的全零数组 arr=np.zeros(5) arr array([ 0., 0., 0., 0., 0.]) ## 创建一个从0到99的数组 arr=np.arange(100) arr array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]) ## 10到99的数组？ arr=np.arange(10,100) arr array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]) ## 0到1，中间有100步，linear space arr=np.linspace(0,1,100) arr array([ 0. , 0.01010101, 0.02020202, 0.03030303, 0.04040404, 0.05050505, 0.06060606, 0.07070707, 0.08080808, 0.09090909, 0.1010101 , 0.11111111, 0.12121212, 0.13131313, 0.14141414, 0.15151515, 0.16161616, 0.17171717, 0.18181818, 0.19191919, 0.2020202 , 0.21212121, 0.22222222, 0.23232323, 0.24242424, 0.25252525, 0.26262626, 0.27272727, 0.28282828, 0.29292929, 0.3030303 , 0.31313131, 0.32323232, 0.33333333, 0.34343434, 0.35353535, 0.36363636, 0.37373737, 0.38383838, 0.39393939, 0.4040404 , 0.41414141, 0.42424242, 0.43434343, 0.44444444, 0.45454545, 0.46464646, 0.47474747, 0.48484848, 0.49494949, 0.50505051, 0.51515152, 0.52525253, 0.53535354, 0.54545455, 0.55555556, 0.56565657, 0.57575758, 0.58585859, 0.5959596 , 0.60606061, 0.61616162, 0.62626263, 0.63636364, 0.64646465, 0.65656566, 0.66666667, 0.67676768, 0.68686869, 0.6969697 , 0.70707071, 0.71717172, 0.72727273, 0.73737374, 0.74747475, 0.75757576, 0.76767677, 0.77777778, 0.78787879, 0.7979798 , 0.80808081, 0.81818182, 0.82828283, 0.83838384, 0.84848485, 0.85858586, 0.86868687, 0.87878788, 0.88888889, 0.8989899 , 0.90909091, 0.91919192, 0.92929293, 0.93939394, 0.94949495, 0.95959596, 0.96969697, 0.97979798, 0.98989899, 1. ]) ## log10空间里1到10的数组，中间有100步 ## numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None) ## base**start是数组的第一个元素，base**stop是数组的最后一个元素 arr=np.logspace(0,1,100,base=10.0) arr array([ 1. , 1.02353102, 1.04761575, 1.07226722, 1.09749877, 1.12332403, 1.149757 , 1.17681195, 1.20450354, 1.23284674, 1.26185688, 1.29154967, 1.32194115, 1.35304777, 1.38488637, 1.41747416, 1.45082878, 1.48496826, 1.51991108, 1.55567614, 1.59228279, 1.62975083, 1.66810054, 1.70735265, 1.7475284 , 1.78864953, 1.83073828, 1.87381742, 1.91791026, 1.96304065, 2.009233 , 2.05651231, 2.10490414, 2.15443469, 2.20513074, 2.25701972, 2.3101297 , 2.36448941, 2.42012826, 2.47707636, 2.53536449, 2.59502421, 2.65608778, 2.71858824, 2.7825594 , 2.84803587, 2.91505306, 2.98364724, 3.05385551, 3.12571585, 3.19926714, 3.27454916, 3.35160265, 3.43046929, 3.51119173, 3.59381366, 3.67837977, 3.76493581, 3.85352859, 3.94420606, 4.03701726, 4.1320124 , 4.22924287, 4.32876128, 4.43062146, 4.53487851, 4.64158883, 4.75081016, 4.86260158, 4.97702356, 5.09413801, 5.21400829, 5.33669923, 5.46227722, 5.59081018, 5.72236766, 5.85702082, 5.9948425 , 6.13590727, 6.28029144, 6.42807312, 6.57933225, 6.73415066, 6.8926121 , 7.05480231, 7.22080902, 7.39072203, 7.56463328, 7.74263683, 7.92482898, 8.11130831, 8.30217568, 8.49753436, 8.69749003, 8.90215085, 9.11162756, 9.32603347, 9.54548457, 9.77009957, 10. ]) ## 创建一个5*5的全零数组 image=np.zeros((5,5)) image array([[ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0.]]) ## 创建一个5*5*5的全1的cube ## astype()方法将数组的元素全部设为整型 cube=np.zeros((5,5,5)).astype(int)+1 cube array([[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]]) ## 或者用更简单的方法创建全1数组，元素是16位浮点精度 cube=np.ones((5,5,5)).astype(np.float16) cube array([[[ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.]], [[ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.]], [[ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.]], [[ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.]], [[ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.], [ 1., 1., 1., 1., 1.]]], dtype=float16) ## NumPy在生成数组时，默认使用系统的字长来创建数组元素 ## 在64位的Python环境中，数组元素默认为64位精度的浮点数 ## 这种设定消耗大量内存，很多时候并非必要 ## 在创建数组时，用户可以自己设定元素的精度，即把dtype参数设为int, numpy.float16, ## numpy.float32, numpy.float64 ## 下面定义了一个全零的整型数组 arr1=np.zeros(2,dtype=int) ## 下面定义了一个全零的浮点型数组 arr2=np.zeros(2,dtype=np.float32) print(arr1) print(arr2) [0 0] [ 0. 0.] ## 数组变形 ## 创建一个125个元素的数组 arr1d=np.arange(125) ## 把数组变形为5*5*5的三维数组 arr3d=arr1d.reshape((5,5,5)) ## 另一种效果相同的变形方法 arr3d=np.reshape(arr1d,(5,5,5)) print(arr3d) ## 把高维数组变形为一维数组 arr4d=np.zeros((10,10,10,10)) arr1d=arr4d.ravel() print(arr1d.shape) ## 值得注意的是，数组的变形只是改变观察数组的角度， ## 并没有新创建数组，变形后的数组和变形前的数组使用的是相同的内存空间 ## 因此改动其中一个数组的元素，另一个数组的元素也会跟着改变 ## 要创建内存中完全不同的数组，需要使用numpy.copy函数 [[[ 0 1 2 3 4] [ 5 6 7 8 9] [ 10 11 12 13 14] [ 15 16 17 18 19] [ 20 21 22 23 24]] [[ 25 26 27 28 29] [ 30 31 32 33 34] [ 35 36 37 38 39] [ 40 41 42 43 44] [ 45 46 47 48 49]] [[ 50 51 52 53 54] [ 55 56 57 58 59] [ 60 61 62 63 64] [ 65 66 67 68 69] [ 70 71 72 73 74]] [[ 75 76 77 78 79] [ 80 81 82 83 84] [ 85 86 87 88 89] [ 90 91 92 93 94] [ 95 96 97 98 99]] [[100 101 102 103 104] [105 106 107 108 109] [110 111 112 113 114] [115 116 117 118 119] [120 121 122 123 124]]] (10000,) 6.1.1.2 记录数组（Record Arrays） ## 数组一般来说是只包含一种数据类型，不过有些时候数组可以用来存储更复杂的数据结构， ## 每列由不同的数据类型组成，叫做记录数组 ## 创建一个全零数组，定义列的类型（i4：32位整数，f4：32位浮点数，a10：长度为10的字符串） recarr=np.zeros((2,),dtype=(&#39;i4,f4,a10&#39;)) ## 创建我们想放进recarr数组的列 col1=np.arange(2)+1 # array([1,2]) col2=np.arange(2,dtype=np.float32) # array([0.,1.], dtype=float32) col3=[&quot;Hello&quot;,&quot;World&quot;] ## 创建一个列表，整合上面3列 toadd=list(zip(col1,col2,col3)) ## 给recarr赋值 recarr[:]=toadd recarr ## 结果中字符串前的&quot;b&quot;：python3.x里默认的str是(py2.x里的)unicode, ## bytes是(py2.x)的str, b”“前缀代表的就是bytes array([(1, 0., b&#39;Hello&#39;), (2, 1., b&#39;World&#39;)], dtype=[(&#39;f0&#39;, &#39;&lt;i4&#39;), (&#39;f1&#39;, &#39;&lt;f4&#39;), (&#39;f2&#39;, &#39;S10&#39;)]) ## 给每一列赋一个名字，默认的名字是f0, f1, f2 recarr.dtype.names=(&quot;Integers&quot;,&quot;Floats&quot;,&quot;Strings&quot;) ## 用列的名字访问一列 recarr[&quot;Integers&quot;] array([1, 2], dtype=int32) 6.1.1.3 索引和切割 ## 要返回任意列，在Python的列表里不太容易，但在NumPy数组里很方便 ## 定义一个列表 alist=[[1,2],[3,4]] ## 把列表转换为一个NumPy数组 arr=np.array(alist) ## 打印(0,1)元素 print(arr[0,1]) ## 打印第二列 print(arr[:,1]) ## 打印第二行 print(arr[1,:]) 2 [2 4] [3 4] ## 条件索引，常用numpy.where()，可以返回数组中需要的索引，基于条件，不考虑维度 ## 创建一个数组 arr=np.arange(5) ## 创建索引数组 index=np.where(arr&gt;2) print(index) ## 根据索引创建需要的数组 new_arr1=arr[index] print(new_arr) ## 使用np.delete()删除特定的索引 ## 删除index中包含的元素 new_arr2=np.delete(arr,index) print(new_arr2) ## 用简单的布尔列表作为下标返回需要的数组 ## 使用布尔索引获得需要的元素比np.where()要迅速，并且可以通过~index轻易地反转布尔数组 index=arr&gt;2 print(index) new_arr=arr[index] print(new_arr) (array([3, 4]),) [3 4] [0 1 2] [False False False True True] [3 4] 6.1.2 布尔语句和NumPy数组 ## 创建一个图片 img1=np.zeros((20,20))+3 img1[4:-4,4:-4]=6 img1[7:-7,7:-7]=9 ## 见Plot A ## compound_index变量存储所有大于2或小于6的下标 index1=img1&gt;2 index2=img1&lt;6 compound_index=index1 &amp; index2 ## 复合索引的语句也可以写成这样： compound_index=(img1&gt;3) &amp; (img1&lt;7) img2=np.copy(img1) img2[compound_index]=0 ## 见Plot B ## 使用更复杂的布尔数组 index3=img1==9 index4=(index1 &amp; index2) | index3 img3=np.copy(img1) img3[index4]=0 ## 见Plot C ## 仅变更数组中选中变量的值 ## 依据标准正态分布（均值为0，方差为1）创建一个100个随机元素的数组 a=rand.randn(100) print(a) ## 去掉不需要的元素 index=a&gt;0.2 b=a[index] ## 在选出的元素上应用某些运算 b=b**2-2 ## 把修改过的元素仍然放回原来的数组，这样就完成了对数组中某些值得变更 a[index]=b print(a) [-1.80712517 -0.13170284 1.93343213 0.80721035 2.52144275 0.16195953 0.11878839 1.88961184 -0.75881407 -1.22866865 -0.73857745 0.64046896 0.73563193 0.71783485 -0.37645069 0.90120663 -0.59161068 -1.16366655 -0.50663906 -0.36447979 -1.8654699 0.92406343 0.8004173 -1.41016169 0.32592465 0.725013 0.29738016 -2.21113871 -0.68122701 0.66455187 -0.32413105 1.13627295 0.13185364 1.38536725 0.19462378 -1.80775106 -0.06199759 -1.30422952 -0.30685345 0.08940313 -0.67023186 -0.15051653 -0.15879759 1.35984567 -0.2328225 -1.7265208 0.67232358 -0.59098342 -1.20227104 -1.08216219 -0.53158487 1.33859499 0.66763318 -0.56431746 0.75334062 1.44683156 1.9512399 0.42510796 0.34020597 0.72372802 -0.10372294 0.184639 0.01761624 -0.69082466 0.36432908 -0.56651026 0.21865567 -0.42096267 -0.73512854 -0.05493638 -1.94869892 0.76399321 1.41936848 0.05750032 -0.12937963 -0.02329108 -1.47156894 -0.84254776 0.75245785 0.07682322 0.96333808 0.92090036 0.76489123 0.63520238 -0.08737849 -1.2083732 0.21328152 0.92891946 0.26792553 0.0672728 -1.74821241 0.69335543 -0.60076278 -0.11200103 -1.4392716 -0.35400569 -0.05871362 0.8178716 1.08160928 0.77033013] [-1.80712517 -0.13170284 1.73815979 -1.34841145 4.35767354 0.16195953 0.11878839 1.57063289 -0.75881407 -1.22866865 -0.73857745 -1.58979952 -1.45884566 -1.48471313 -0.37645069 -1.1878266 -0.59161068 -1.16366655 -0.50663906 -0.36447979 -1.8654699 -1.14610677 -1.35933214 -1.41016169 -1.89377312 -1.47435616 -1.91156504 -2.21113871 -0.68122701 -1.55837081 -0.32413105 -0.70888379 0.13185364 -0.08075759 0.19462378 -1.80775106 -0.06199759 -1.30422952 -0.30685345 0.08940313 -0.67023186 -0.15051653 -0.15879759 -0.15081976 -0.2328225 -1.7265208 -1.547981 -0.59098342 -1.20227104 -1.08216219 -0.53158487 -0.20816344 -1.55426593 -0.56431746 -1.43247792 0.09332155 1.80733714 -1.81928322 -1.8842599 -1.47621775 -0.10372294 0.184639 0.01761624 -0.69082466 -1.86726432 -0.56651026 -1.9521897 -0.42096267 -0.73512854 -0.05493638 -1.94869892 -1.41631438 0.01460689 0.05750032 -0.12937963 -0.02329108 -1.47156894 -0.84254776 -1.43380718 0.07682322 -1.07197974 -1.15194253 -1.4149414 -1.59651793 -0.08737849 -1.2083732 -1.95451099 -1.13710863 -1.92821591 0.0672728 -1.74821241 -1.51925824 -0.60076278 -0.11200103 -1.4392716 -0.35400569 -0.05871362 -1.33108605 -0.83012136 -1.40659148] 6.1.3 NumPy读写文件 ## NumPy读文本文件中的矩阵 arr=np.loadtxt(&quot;data5/somefile.txt&quot;) arr array([[ 2., 3., 5.], [ 7., 11., 13.], [ 17., 19., 23.]]) ## NumPy写矩阵到文本文件中 ## numpy.savetxt(fname, X, fmt=&#39;%.18e&#39;, delimiter=&#39; &#39;, newline=&#39;\\n&#39;, ## header=&#39;&#39;, footer=&#39;&#39;, comments=&#39;# &#39;, encoding=None)[source] np.savetxt(&quot;data5/somenewfile.txt&quot;,arr,&quot;%d&quot;,&quot;\\t&quot;) ## loadtxt()读取文件中复杂的数据结构 recarr=np.loadtxt(&quot;data5/example.txt&quot;, dtype={ &quot;names&quot;:(&quot;Gene_ID&quot;,&quot;Sample1&quot;,&quot;Sample2&quot;,&quot;Sample3&quot;), &quot;formats&quot;:(&quot;S6&quot;,&quot;f4&quot;,&quot;f4&quot;,&quot;f4&quot;)}) recarr array([(b&#39;Gene1&#39;, 2.29999995, 5.69999981, 11.13000011), (b&#39;Gene2&#39;, 17.19000053, 23.29000092, 31.37000084)], dtype=[(&#39;Gene_ID&#39;, &#39;S6&#39;), (&#39;Sample1&#39;, &#39;&lt;f4&#39;), (&#39;Sample2&#39;, &#39;&lt;f4&#39;), (&#39;Sample3&#39;, &#39;&lt;f4&#39;)]) 6.1.4 NumPy的Math模块 6.1.4.1 线性代数 ## 解矩阵方程AX=B ## 定义矩阵A, B A=np.matrix([[3,6,-5],[1,-3,2],[5,-1,4]]) B=np.matrix([[12],[-2],[10]]) ## 解矩阵方程，等号两边同时左乘A^(-1) X=A**-1*B print(X) [[ 1.75] [ 1.75] [ 0.75]] ## 使用np.array，更快 a=np.array([[3,6,-5],[1,-3,2],[5,-1,4]]) b=np.array([[12],[-2],[10]]) x=np.linalg.inv(a).dot(b) print(x) [[ 1.75] [ 1.75] [ 0.75]] 6.2 SciPy 6.2.1 最优化和最小化 6.2.1.1 数据建模和拟合 from scipy.optimize import curve_fit ## 拟合线性分布 ## 创建一个函数，用来建模和创建数据 def func(x,a,b): return a*x+b ## 生成干净的数据 x=np.linspace(0,10,100) y=func(x,1,2) ## 加入噪声 yn=y+0.9*np.random.normal(size=len(x)) ## 在有噪声的数据上应用curve_fit ## popt返回给定模型（func）下的参数的最佳拟合值 ## pcov返回一个矩阵表示拟合的质量，矩阵对角线上的值是各参数的方差 popt,pcov=curve_fit(func,x,yn) print(popt) [ 1.06107439 1.7517619 ] fig=plt.figure() ax1=fig.add_subplot(2,2,1) ax2=fig.add_subplot(2,2,2) ax3=fig.add_subplot(2,2,3) ax4=fig.add_subplot(2,2,4) ax1.scatter(x,y,1) ax2.scatter(x,yn,1) ax3.scatter(x,yn,1,&quot;red&quot;) ax3.plot(x,popt[0]*x+popt[1],&quot;blue&quot;) ax4.scatter(x,yn,1,&quot;red&quot;) ax4.plot(x,y,&quot;green&quot;) ax4.plot(x,popt[0]*x+popt[1],&quot;blue&quot;) plt.show() ## 拟合高斯分布 ## 创建一个函数，用来建模和创建数据 def func(x,a,b,c): return a*np.exp(-(x-b)**2/(2*c**2)) ## 生成干净的数据 x=np.linspace(0,10,100) y=func(x,1,5,2) ## 加入噪声 yn=y+0.2*np.random.normal(size=len(x)) ## 在有噪声的数据上应用curve_fit ## popt返回给定模型（func）下的参数的最佳拟合值 ## pcov返回一个矩阵表示拟合的质量，矩阵对角线上的值是各参数的方差 popt, pcov = curve_fit(func, x, yn) print(popt) [ 1.03822218 5.01637962 -1.88413558] fig=plt.figure() ax1=fig.add_subplot(2,2,1) ax2=fig.add_subplot(2,2,2) ax3=fig.add_subplot(2,2,3) ax4=fig.add_subplot(2,2,4) ax1.scatter(x,y,1) ax2.scatter(x,yn,1) ax3.scatter(x,yn,1,&quot;red&quot;) ax3.plot(x,popt[0]*np.exp(-(x-popt[1])**2/(2*popt[2]**2)),&quot;blue&quot;) ax4.scatter(x,yn,1,&quot;red&quot;) ax4.plot(x,y,&quot;green&quot;) ax4.plot(x,popt[0]*np.exp(-(x-popt[1])**2/(2*popt[2]**2)),&quot;blue&quot;) plt.show() ## 拟合两个高斯分布的线性组合 ## 创建一个函数，用来建模和创建数据 def func(x,a0,b0,c0,a1,b1,c1): return a0*np.exp(-(x-b0)**2/(2*c0**2))+a1*np.exp(-(x-b1)**2/(2*c1**2)) ## 生成干净的数据 x=np.linspace(0,20,200) y=func(x,1,3,1,-2,15,0.5) ## 加入噪声 yn=y+0.2*np.random.normal(size=len(x)) ## 在有噪声的数据上应用curve_fit ## popt返回给定模型（func）下的参数的最佳拟合值 ## pcov返回一个矩阵表示拟合的质量，矩阵对角线上的值是各参数的方差 popt, pcov = curve_fit(func, x, yn) print(popt) [ -2.04644312 14.99180963 0.50668406 1.05196114 2.97782597 0.99894884] fig=plt.figure() ax1=fig.add_subplot(2,2,1) ax2=fig.add_subplot(2,2,2) ax3=fig.add_subplot(2,2,3) ax4=fig.add_subplot(2,2,4) ax1.scatter(x,y,1) ax2.scatter(x,yn,1) ax3.scatter(x,yn,1,&quot;red&quot;) ax3.plot(x,popt[0]*np.exp(-(x-popt[1])**2/(2*popt[2]**2))+ popt[3]*np.exp(-(x-popt[4])**2/(2*popt[5]**2)),&quot;blue&quot;) ax4.scatter(x,yn,1,&quot;red&quot;) ax4.plot(x,y,&quot;green&quot;) ax4.plot(x,popt[0]*np.exp(-(x-popt[1])**2/(2*popt[2]**2))+ popt[3]*np.exp(-(x-popt[4])**2/(2*popt[5]**2)),&quot;blue&quot;) ax4.legend(loc=0, bbox_to_anchor=(1,1)) plt.show() 6.2.1.2 函数的解 from scipy.optimize import fsolve line=lambda x:x+3 solution=fsolve(line,-2) print(solution) [-3.] fig = plt.figure() ax=fig.add_subplot(1,1,1) x=np.linspace(-10,10,100) zeros=np.zeros(100) ax.plot(x,line(x),&quot;blue&quot;,label=&quot;Function&quot;) ax.plot(x,zeros,&quot;g--&quot;,label=&quot;y=0&quot;) ax.scatter(solution,line(solution),25,&quot;red&quot;,label=&quot;Root&quot;) ax.legend(loc=&quot;best&quot;, bbox_to_anchor=(1,1)) plt.show() ## 找到两个函数的交点 ## 定义一个函数来简化求交点的过程 def findIntersection(func1,func2,x0): return fsolve(lambda x:func1(x)-func2(x),x0) ## 定义两个函数，准备求它们的交点 funky=lambda x:np.cos(x/5)*np.sin(x/2) line=lambda x:0.01*x-0.5 ## 设置函数的定义域，求两个函数的交点 x=np.linspace(0,45,10000) result=findIntersection(funky,line,[15,20,30,35,40,45]) ## 打印交点的坐标 print(result,line(result)) [ 13.40773078 18.11366128 31.78330863 37.0799992 39.84837786 43.8258775 ] [-0.36592269 -0.31886339 -0.18216691 -0.12920001 -0.10151622 -0.06174122] fig = plt.figure() ax=fig.add_subplot(1,1,1) x=np.linspace(0,45,10000) ax.plot(x,funky(x),&quot;blue&quot;,label=&quot;Funky&quot;) ax.plot(x,line(x),&quot;green&quot;,label=&quot;Line&quot;) ax.scatter(result,line(result),25,&quot;red&quot;) ax.legend(loc=&quot;best&quot;, bbox_to_anchor=(1,1)) plt.show() 6.2.2 插值 插值法在离散数据的基础上补插连续函数，使得这条连续曲线通过全部给定的离散数据点。 插值是离散函数逼近的重要方法，利用它可通过函数在有限个点处的取值状况，估算出函数在其他点处的近似值。 常用来填充图像变换时像素之间的空隙。 计算插值有两种基本方法： 用一个函数对整个数据集进行拟合 对数据集不同的部分用几个不同函数拟合，各函数的连接点都是光滑的 第二种方法称为样条插值，当数据的函数形式复杂的时候，样条插值是非常强大的工具 from scipy.interpolate import interp1d ## 创建离散数据集 x=np.linspace(0,10*np.pi,20) y=np.cos(x) ## 分别用线性函数和二次函数，对数据进行插值 fl=interp1d(x,y,kind=&quot;linear&quot;) fq=interp1d(x,y,kind=&quot;quadratic&quot;) ## 得到两个连续函数上的点 xint=np.linspace(x.min(),x.max(),1000) yintl=fl(xint) yintq=fq(xint) fig = plt.figure() ax=fig.add_subplot(1,1,1) ax.plot(x,y,&quot;ro&quot;,xint,yintl,&quot;g-&quot;,xint,yintq,&quot;b-&quot;) plt.show() from scipy.interpolate import UnivariateSpline ## 对有噪声的函数进行插值 ## 创建数据集，加入人工噪声 sample=30 x=np.linspace(1,10*np.pi,sample) y=np.cos(x)+np.log10(x)+np.random.randn(sample)/10 ## 对数据进行插值，参数s是光滑因子，若s=0，插值会经过所有点不考虑噪声，若s=1，则考虑噪声 f=UnivariateSpline(x,y,s=1) ## 得到插值函数上的点 xint=np.linspace(x.min(),x.max(),1000) yint=f(xint) fig = plt.figure() ax=fig.add_subplot(1,1,1) x1000=np.linspace(1,10*np.pi,1000) y1000=np.cos(x1000)+np.log10(x1000) ax.plot(x,y,&quot;ro&quot;,x1000,y1000,&quot;b-&quot;,xint,yint,&quot;g-&quot;) plt.show() from scipy.interpolate import griddata # 创建一个1000*1000像素的图片，在图片上随机选1000个点，看插值函数如何能根据这1000个点重构图片 ## 创建一个函数 ripple=lambda x,y:np.sqrt(x**2+y**2)+np.sin(x**2+y**2) ## 生成网格数据，复数1000j表示在0到5之间生成1000个点，包含0和5 grid_x, grid_y = np.mgrid[0:5:1000j, 0:5:1000j] ## 随机生成插值函数可见的1000个点的抽样 xy = np.random.rand(1000, 2) sample = ripple(xy[:,0] * 5 , xy[:,1] * 5) ## 用三次函数方法生成抽样数据的插值 grid_z0 = griddata(xy * 5, sample, (grid_x, grid_y), method=&#39;cubic&#39;) ## 用线性方法生成抽样数据的插值 grid_z1 = griddata(xy * 5, sample, (grid_x, grid_y), method=&#39;linear&#39;) ## 用Nearest方法生成抽样数据的插值 grid_z2 = griddata(xy * 5, sample, (grid_x, grid_y), method=&#39;nearest&#39;) plt.subplot(221) plt.title(&#39;Original&#39;) plt.imshow(ripple(grid_x, grid_y).T,extent=(0,5,0,5)) plt.plot(xy[:,0]*5, xy[:,1]*5, &#39;b.&#39;,ms=3) plt.subplot(222) plt.title(&#39;Cubic&#39;) plt.imshow(grid_z0.T,extent=(0,5,0,5)) plt.subplot(223) plt.title(&#39;Linear&#39;) plt.imshow(grid_z1.T,extent=(0,5,0,5)) plt.subplot(224) plt.title(&#39;Nearest&#39;) plt.imshow(grid_z2.T,extent=(0,5,0,5)) plt.show() "],["Py3_test.html", "7 易生信Python培训练习和考核题目", " 7 易生信Python培训练习和考核题目 B 站视频课程 （生信宝典知乎号、视频号同步更新）https://space.bilibili.com/362709786/lists/1988354?type=season 3*2**2的输出是多少？(1分) 8 % 4的输出是多少？(1分) 32 + '32'的输出是什么？(1分) 32 &gt; '32'的输出是什么？(1分) 'Sheng Xin Bao Dian'.find('x')和'Sheng Xin Bao Dian'.find('X')的输出分别是？(2分) 一句话计算'Sheng Xin Bao Dian'字符串中n的数目？(1分) 写出下面10段程序的输出？(1分/段) aList = [1, 2, 3] bList = aList bList.append(4) aList aList = [1, 2, 3] cList = aList[:] cList.append(4) aList aList = [1,1,2,2,3,5,4,3] aSet = set(aList) aSet [1, 2, 3] * 2 [i**2 for i in [1,2,3]] dict([(i, i**2) for i in range(5)]) import re re.findall(&quot;[Ii]mageGP&quot;, &quot;www.bic.ac.cn/ImageGP&quot;) &#39; &#39;.join([&quot;Sheng&quot;, &quot;Xin&quot;, &quot;Bao&quot;, &quot;Dian&quot;]) def sumNumber(a, b): return a + b sumNumber(2,3) def sumNumber(a, b): return a + b print(sumNumber(2,3)) 写程序以下面列表中每个元素为key，元素出现的次数为value，构建一个字典，并遍历字典按元素的ASCII码顺序输出？(5分) aList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;,&#39;e&#39;, &#39;A&#39;] 对教案中脑筋急转弯问题的解法进行优化; 问题是：现有100元钱，需要买100个物品，其中铅笔盒单价5元，笔单价3元，橡皮单价0.5元，怎么组合可以把100元花完，同时三种物品的个数和为100，请用编程解决。 (3分) 写程序用高斯的计算方式计算1+2+3+...+100的加和。(3分) 指出下面每个程序运行时可能会出现的错误。(1分/段) aList = [1,2,3] aDict = {} aDict[aList] = 1 b = aDict[&#39;a&#39;] if 1: print(&quot;Sheng xin bao dian great!&quot;) 32 + &#39;32&#39; aList = [1, 2, 3] aList.add(4) aList = [1, 2, 3] &#39;&#39;.join(aList) int(&#39;a&#39;) 3 / 0 for i in range(10) print(L) &#39;Sheng Xin * 3 type = 1 Python文件读写函数open的mode参数中r, w, a, t, b, x分别是什么意思？(3分) Python中如何获取当前所在的工作目录? 如何修改工作目录？(3分) Python中连接多个字符串的方法有哪些？优缺点是什么？(3分) print(\"%.2f%%\" % (1/3))的输出是什么？(2分) 描述下语句import pandas as pd做了什么操作？(2分) 教案中IDmap程序用pandas实现 (GRCh38.idmap,ensm.id)。(5分) Jupyter中%%writefile, %%run 宏命令的用途是什么？(2分) 找出教案中TP53 mRNA序列中的ORF (human_TP53_mRNA.fa)。(5分) 列出教案中大肠杆菌基因组中限制性内切酶SecI的切割位置 (Ecoli.fa)。(5分) 计算data/test1.fa中每条序列的GC含量。(5分) 不使用pandas，写Python脚本处理Pandas教案中的TPM表达矩阵的提取和合并？(ENCFF060LPA.tsv, ENCFF262OBL.tsv, ENCFF289HGQ.tsv, ENCFF673KYR.tsv) (8分) 给定FASTA格式的文件(test1.fa 和 test2.fa)，写一个程序 cat.py 读入文件，并输出到屏幕 (2分) 用到的知识点 open(file) for .. in loop print() strip() function 给定FASTQ格式的文件(test1.fq), 写一个程序 cat.py 读入文件，并输出到屏幕 (2分) 用到的知识点 同上 写程序 splitName.py, 读入test2.fa, 并取原始序列名字第一个空格前的名字为处理后的序列名字，输出到屏幕 (2分) 用到的知识点 split 字符串的索引 输出格式为： &gt;NM_001011874 gcggcggcgggcgagcgggcgctggagtaggagctg....... 写程序 formatFasta.py, 读入test2.fa，把每条FASTA序列连成一行然后输出 (2分) 用到的知识点 join strip 输出格式为: &gt;NM_001011874 gcggcggcgggc......TCCGCTG......GCGTTCACC......CGGGGTCCGGAG 写程序 formatFasta-2.py, 读入test2.fa，把每条FASTA序列分割成80个字母一行的序列 (2分) 用到的知识点 字符串切片操作 range 输出格式为 &gt;NM_001011874 gcggcggcgc.(60个字母).TCCGCTGACG #(每行80个字母) acgtgctacg.(60个字母).GCGTTCACCC ACGTACGATG(最后一行可不足80个字母) 写程序 sortFasta.py, 读入test2.fa, 并取原始序列名字第一个空格前的名字为处理后的序列名字，排序后输出 (2分) 用到的知识点 sort dict aDict[key] = [] aDict[key].append(value) 提取给定名字的序列 (2分) 写程序 grepFasta.py, 提取fasta.name中名字对应的test2.fa的序列，并输出到屏幕。 写程序 grepFastq.py, 提取fastq.name中名字对应的test1.fq的序列，并输出到文件。 用到的知识点 print &gt;&gt;fh, or fh.write() 取模运算，4 % 2 == 0 写程序 screenResult.py, 筛选test.expr中foldChange大于2的基因并且padj小于0.05的基，可以输出整行或只输出基因名字。(4分) 用到的知识点 逻辑与操作符 and 文件中读取的内容都为字符串，需要用int转换为整数，float转换为浮点数 写程序 transferMultipleColumToMatrix.py 将文件(multipleColExpr.txt)中基因在多个组织中的表达数据转换为矩阵形式，并绘制热图。(6分) 用到的知识点 aDict[‘key’] = {} aDict[‘key’][‘key2’] = value if key not in aDict aDict = {‘ENSG00000000003’: {“A-431”: 21.3, “A-549”, 32.5,…},“ENSG00000000003”:{},} 输入格式(只需要前3列就可以) Gene Sample Value Unit Abundance ENSG00000000003 A-431 21.3 FPKM Medium ENSG00000000003 A-549 32.5 FPKM Medium ENSG00000000003 AN3-CA 38.2 FPKM Medium ENSG00000000003 BEWO 31.4 FPKM Medium ENSG00000000003 CACO-2 63.9 FPKM High ENSG00000000005 A-431 0.0 FPKM Not detected ENSG00000000005 A-549 0.0 FPKM Not detected ENSG00000000005 AN3-CA 0.0 FPKM Not detected ENSG00000000005 BEWO 0.0 FPKM Not detected ENSG00000000005 CACO-2 0.0 FPKM Not detected 输出格式 Name A-431 A-549 AN3-CA BEWO CACO-2 ENSG00000000460 25.2 14.2 10.6 24.4 14.2 ENSG00000000938 0.0 0.0 0.0 0.0 0.0 ENSG00000001084 19.1 155.1 24.4 12.6 23.5 ENSG00000000457 2.8 3.4 3.8 5.8 2.9 写程序 reverseComplementary.py计算序列 ACGTACGTACGTCACGTCAGCTAGAC的反向互补序列。(2分) 用到的知识点 reverse list(seq) 写程序 collapsemiRNAreads.py转换smRNA-Seq的测序数据。(5分) 输入文件格式(mir.collapse, tab-分割的两列文件，第一列为序列，第二列为序列被测到的次数) ID_REF VALUE ACTGCCCTAAGTGCTCCTTCTGGC 2 ATAAGGTGCATCTAGTGCAGATA 25 TGAGGTAGTAGTTTGTGCTGTTT 100 TCCTACGAGTTGCATGGATTC 4 输出文件格式 (mir.collapse.fa, 名字的前3个字母为样品的特异标示，中间的数字表示第几条序列，是序列名字的唯一标示，第三部分是x加每个reads被测到的次数。三部分用下划线连起来作为fasta序列的名字。) &gt;ESB_1_x2 ACTGCCCTAAGTGCTCCTTCTGGC &gt;ESB_2_x25 ATAAGGTGCATCTAGTGCAGATA &gt;ESB_3_x100 TGAGGTAGTAGTTTGTGCTGTTT &gt;ESB_4_x4 TCCTACGAGTTGCATGGATTC 简化的短序列匹配程序 (map.py) 把short.fa中的序列比对到ref.fa, 输出短序列匹配到ref.fa文件中哪些序列的哪些位置。(10分) 用到的知识点 find 输出格式 (输出格式为bed格式，第一列为匹配到的染色体，第二列和第三列为匹配到染色体序列的起始终止位置（位置标记以0为起始，代表第一个位置；终止位置不包含在内，第一个例子中所示序列的位置是(199,208](前闭后开，实际是chr1染色体第199-206的序列，0起始). 第4列为短序列自身的序列.)。 附加要求：可以只匹配到给定的模板链，也可以考虑匹配到模板链的互补链。这时第5列可以为短序列的名字，第六列为链的信息，匹配到模板链为’+‘，匹配到互补链为’-’。注意匹配到互补链时起始位置也是从模板链的5’端算起的。 chr1 199 208 TGGCGTTCA chr1 207 216 ACCCCGCTG chr2 63 70 AAATTGC chr3 0 7 AATAAAT 备注： 每个提到提到的“用到的知识点”为相对于前面的题目新增的知识点，请综合考虑。此外，对于不同的思路并不是所有提到的知识点都会用着，而且也可能会用到未提到的知识点。但是所有知识点都在前面的讲义部分有介绍。 每个程序对于你身边会写的人来说都很简单，因此你一定要克制住，独立去把答案做出，多看错误提示，多比对程序输出结果和预期结果的差异。 学习锻炼“读程序”，即对着文件模拟整个的读入、处理过程来发现可能的逻辑问题。 程序运行没有错误不代表你写的程序完成了你的需求，你要去查验输出结果是不是你想要的。 关于程序调试 在初写程序时，可能会出现各种各样的错误，常见的有缩进不一致，变量名字拼写错误，丢失冒号，文件名未加引号等，这时要根据错误提示查看错误类型是什么，出错的是哪一行来定位错误。当然，有的时候报错的行自身不一定有错，可能是其前面或后面的行出现了错误。 用脑袋运行程序：当程序写作完成后，自己尝试对着数据文件，一行一行的执行程序，来看程序的运行是否与自己想干的活一致，有没有纰漏。 当结果不符合预期时，要学会使用print来查看每步的操作是否正确，比如我读入了字典，我就打印下字典，看看读入的是不是我想要的，是否含有不该存在的字符；或者在每个判断句、函数调入的情况下打印个字符，来跟踪程序的运行轨迹 import re re.findall(&quot;[Ii]mageGP&quot;, &quot;www.bic.ac.cn/ImageGP&quot;) [&#39;ImageGP&#39;] &#39; &#39;.join([&quot;Sheng&quot;, &quot;Xin&quot;, &quot;Bao&quot;, &quot;Dian&quot;]) &#39;Sheng Xin Bao Dian&#39; # 写程序以下面列表中每个元素为key，元素出现的次数为value， # 构建一个字典，并遍历字典按元素的ASCII码顺序输出？ aList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;,&#39;e&#39;, &#39;A&#39;] aDict = {} uniqList = list(set(aList)) aDict = dict([(i,aList.count(i)) for i in uniqList]) uniqList.sort() for key in uniqList: print(key, aDict[key], sep=&quot;--&gt;&quot;) #for item in uniqList: # aDict[item] = aDict.get(item,0) + 1 A--&gt;1 a--&gt;2 b--&gt;1 c--&gt;1 d--&gt;1 e--&gt;1 # 写程序以下面列表中每个元素为key，元素出现的次数为value， # 构建一个字典，并遍历字典按元素的ASCII码顺序输出？ aList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;,&#39;e&#39;, &#39;A&#39;] aDict = {} for item in aList: aDict[item] = aDict.get(item,0) + 1 keyL = list(aDict.keys()) keyL.sort() for key in keyL: print(key, aDict[key], sep=&quot;\\t&quot;) A 1 a 2 b 1 c 1 d 1 e 1 aList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;e&#39;, &#39;A&#39;] aDict = {} for i in aList: aDict.setdefault(i, 0) aDict[i] += 1 print(aDict) {&#39;a&#39;: 2, &#39;b&#39;: 1, &#39;c&#39;: 1, &#39;d&#39;: 1, &#39;e&#39;: 1, &#39;A&#39;: 1} aDict = {} aList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;,&#39;e&#39;, &#39;A&#39;] #uniL = list(set(aList)) for i in aList: aDict[i] = aDict.get(i,0)+1 #aDict += 1 #break print(aDict) {&#39;a&#39;: 2, &#39;b&#39;: 1, &#39;c&#39;: 1, &#39;d&#39;: 1, &#39;e&#39;: 1, &#39;A&#39;: 1} aList = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;,&#39;e&#39;, &#39;A&#39;] aSet = set(aList) aSet for i in aSet: print (i,aList.count(i)) a 2 d 1 A 1 b 1 e 1 c 1 list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;d&#39;,&#39;e&#39;, &#39;A&#39;] dic = {} for i in list: dic[i] = list.count(i) print(dic) #写程序用高斯的计算方式计算1+2+3+...+100的加和 n = 100 (1+n) * (n/2) 5050.0 n = 99 (1+n) * (n/2) 4950.0 import pandas as pd idmap = pd.read_table(&quot;data/GRCh38.idmap&quot;, header=0, index_col=0) ensmL = [line.strip() for line in open(&quot;data/ensm.id&quot;)] idmap = idmap[idmap.index.isin(ensmL)] idmap[&quot;Associated Gene Name&quot;] Gene ID ENSG00000252303 RNU6-280P ENSG00000281771 Y_RNA ENSG00000281256 RP11-222G7.2 ENSG00000283272 Clostridiales-1 ENSG00000280864 RP11-654C22.2 ENSG00000280792 RP11-315F22.1 ENSG00000282878 RP11-399E6.1 ENSG00000283276 ABBA01000934.1 ENSG00000281822 RNU1-62P ENSG00000281384 AC093802.1 ENSG00000280505 RP11-654C22.1 ENSG00000281764 RP11-399E6.2 ENSG00000281316 DPPA2P2 ENSG00000280963 SERTAD4-AS1 ENSG00000280775 RNA5SP136 ENSG00000281876 RP11-399E6.4 ENSG00000281766 RYBP ENSG00000281518 FOXO6 ENSG00000281614 INPP5D ENSG00000280584 OBP2B ENSG00000281230 SERTAD4 ENSG00000281917 SLC16A1 Name: Associated Gene Name, dtype: object mRNA = [] for line in open(&quot;data/human_TP53_mRNA.fa&quot;): if line[0] == &quot;&gt;&quot;: continue else: mRNA.append(line.strip()) #-------------------------------- mRNA = &#39;&#39;.join(mRNA) orf = re.compile(&quot;(A[TU]G(...){99,}?([TU]AA|[TU]AG|[TU]GA))&quot;) for i in orf.findall(mRNA): print(i[0]) ATGGGATTGGGGTTTTCCCCTCCCATGTGCTCAAGACTGGCGCTAAAAGTTTTGAGCTTCTCAAAAGTCTAGAGCCACCGTCCAGGGAGCAGGTAGCTGCTGGGCTCCGGGGACACTTTGCGTTCGGGCTGGGAGCGTGCTTTCCACGACGGTGACACGCTTCCCTGGATTGGCAGCCAGACTGCCTTCCGGGTCACTGCCATGGAGGAGCCGCAGTCAGATCCTAGCGTCGAGCCCCCTCTGAGTCAGGAAACATTTTCAGACCTATGGAAACTACTTCCTGAAAACAACGTTCTGTCCCCCTTGCCGTCCCAAGCAATGGATGATTTGATGCTGTCCCCGGACGATATTGAACAATGGTTCACTGAAGACCCAGGTCCAGATGAAGCTCCCAGAATGCCAGAGGCTGCTCCCCCCGTGGCCCCTGCACCAGCAGCTCCTACACCGGCGGCCCCTGCACCAGCCCCCTCCTGGCCCCTGTCATCTTCTGTCCCTTCCCAGAAAACCTACCAGGGCAGCTACGGTTTCCGTCTGGGCTTCTTGCATTCTGGGACAGCCAAGTCTGTGACTTGCACGTACTCCCCTGCCCTCAACAAGATGTTTTGCCAACTGGCCAAGACCTGCCCTGTGCAGCTGTGGGTTGATTCCACACCCCCGCCCGGCACCCGCGTCCGCGCCATGGCCATCTACAAGCAGTCACAGCACATGACGGAGGTTGTGAGGCGCTGCCCCCACCATGAGCGCTGCTCAGATAGCGATGGTCTGGCCCCTCCTCAGCATCTTATCCGAGTGGAAGGAAATTTGCGTGTGGAGTATTTGGATGACAGAAACACTTTTCGACATAGTGTGGTGGTGCCCTATGAGCCGCCTGAGGTTGGCTCTGACTGTACCACCATCCACTACAACTACATGTGTAACAGTTCCTGCATGGGCGGCATGAACCGGAGGCCCATCCTCACCATCATCACACTGGAAGACTCCAGTGGTAATCTACTGGGACGGAACAGCTTTGAGGTGCGTGTTTGTGCCTGTCCTGGGAGAGACCGGCGCACAGAGGAAGAGAATCTCCGCAAGAAAGGGGAGCCTCACCACGAGCTGCCCCCAGGGAGCACTAAGCGAGCACTGCCCAACAACACCAGCTCCTCTCCCCAGCCAAAGAAGAAACCACTGGATGGAGAATATTTCACCCTTCAGATCCGTGGGCGTGAGCGCTTCGAGATGTTCCGAGAGCTGAATGAGGCCTTGGAACTCAAGGATGCCCAGGCTGGGAAGGAGCCAGGGGGGAGCAGGGCTCACTCCAGCCACCTGAAGTCCAAAAAGGGTCAGTCTACCTCCCGCCATAAAAAACTCATGTTCAAGACAGAAGGGCCTGACTCAGACTGA ATGGGGAGTAGGACATACCAGCTTAGATTTTAAGGTTTTTACTGTGAGGGATGTTTGGGAGATGTAAGAAATGTTCTTGCAGTTAAGGGTTAGTTTACAATCAGCCACATTCTAGGTAGGGGCCCACTTCACCGTACTAACCAGGGAAGCTGTCCCTCACTGTTGAATTTTCTCTAACTTCAAGGCCCATATCTGTGAAATGCTGGCATTTGCACCTACCTCACAGAGTGCATTGTGAGGGTTAATGAAATAATGTACATCTGGCCTTGAAACCACCTTTTATTACATGGGGTCTAGAACTTGACCCCCTTGAGGGTGCTTGTTCCCTCTCCCTGTTGGTCGGTGGGTTGGTAG ATGATGATCTGGATCCACCAAGACTTGTTTTATGCTCAGGGTCAATTTCTTTTTTCTTTTTTTTTTTTTTTTTTCTTTTTCTTTGAGACTGGGTCTCGCTTTGTTGCCCAGGCTGGAGTGGAGTGGCGTGATCTTGGCTTACTGCAGCCTTTGCCTCCCCGGCTCGAGCAGTCCTGCCTCAGCCTCCGGAGTAGCTGGGACCACAGGTTCATGCCACCATGGCCAGCCAACTTTTGCATGTTTTGTAGAGATGGGGTCTCACAGTGTTGCCCAGGCTGGTCTCAAACTCCTGGGCTCAGGCGATCCACCTGTCTCAGCCTCCCAGAGTGCTGGGATTACAATTGTGAGCCACCACGTCCAGCTGGAAGGGTCAACATCTTTTACATTCTGCAAGCACATCTGCATTTTCACCCCACCCTTCCCCTCCTTCTCCCTTTTTATATCCCATTTTTATATCGATCTCTTATTTTACAATAA #SecI识别CCNNGG ecoli = [] for line in open(&quot;data/Ecoli.fa&quot;): if line[0] != &#39;&gt;&#39;: ecoli.append(line.strip()) #print(line.strip()) #--------------- ecoli = &#39;&#39;.join(ecoli) secI = re.compile(&quot;CC..GG&quot;) for i in secI.finditer(ecoli): print(i.start()) 174 299 556 lineL = [] for line in open(&quot;data/Ecoli.fa&quot;): line = line.strip() if line[0] == &quot;&gt;&quot;: continue else: lineL.append(line) #--------------------------- seq = &#39;&#39;.join(lineL) seci = re.compile(&quot;CC[ATGC]GG&quot;) print(seci) re.compile(&#39;CC[ATGC]GG&#39;) help(re.finditer) Help on function finditer in module re: finditer(pattern, string, flags=0) Return an iterator over all non-overlapping matches in the string. For each match, the iterator returns a match object. Empty matches are included in the result. gc_cnt = 0 seqLen = 0 for line in open(&quot;data/test1.fa&quot;): if line[0] == &#39;&gt;&#39;: if seqLen: gc_percent = gc_cnt / seqLen * 100 print(key, round(gc_percent,2),&quot;%&quot;) gc_cnt = seqLen = 0 key = line.split()[0][1:] else: line = line.strip().upper() gc_cnt += line.count(&#39;C&#39;) + line.count(&#39;G&#39;) seqLen += len(line) #------------------------------- if seqLen: gc_percent = gc_cnt / seqLen * 100 print(key, round(gc_percent,2),&quot;%&quot;) NM_001011874 81.43 % NM_001195662 42.86 % NM_0112835 37.14 % NM_011283 37.14 % for line in open(&quot;data/test1.fa&quot;): if line[0] == &quot;&gt;&quot;: continue else: line = line.strip().upper() gc_cnt = line.count(&quot;G&quot;) + line.count(&quot;C&quot;) total_len = len(line) gc_per = gc_cnt / total_len * 100 print(round(gc_per,2)) 81.43 42.86 37.14 37.14 count = 5 for line in open(&quot;data/ENCFF060LPA.tsv&quot;): if count == 0: break print(line) count -= 1 gene_id transcript_id(s) length effective_length expected_count TPM FPKM ENSG00000000003.14 ENST00000373020.8,ENST00000494424.1,ENST00000496771.5,ENST00000612152.4,ENST00000614008.4 2240.53 2020.49 5126.00 6.64 18.24 ENSG00000000005.5 ENST00000373031.4,ENST00000485971.1 940.50 720.47 0.00 0.00 0.00 ENSG00000000419.12 ENST00000371582.8,ENST00000371584.8,ENST00000371588.9,ENST00000413082.1,ENST00000466152.5,ENST00000494752.1 1072.03 851.99 3222.00 9.91 27.19 ENSG00000000457.13 ENST00000367770.5,ENST00000367771.10,ENST00000367772.8,ENST00000423670.1,ENST00000470238.1 3527.59 3307.55 1092.00 0.86 2.37 fileL = [&quot;data/ENCFF060LPA.tsv&quot;, &quot;data/ENCFF262OBL.tsv&quot;, &quot;data/ENCFF289HGQ.tsv&quot;, &quot;data/ENCFF673KYR.tsv&quot;] &#39;&#39;&#39; aDict = { &#39;ENCFF060LPA&#39;: {&#39;a&#39;: 5, &#39;b&#39;: 3}, &#39;ENCFF289HGQ&#39;: {&#39;a&#39;: 3, &#39;c&#39;: 5}, } aDict = { &#39;a&#39;: {&#39;ENCFF060LPA&#39;: 5, &#39;ENCFF289HGQ&#39;:3}, &#39;b&#39;: {&#39;ENCFF060LPA&#39;: 3}, &#39;c&#39;: {&#39;ENCFF289HGQ&#39;: 5} } &#39;&#39;&#39; aDict = {} labelL = [] for file_name in fileL: label = file_name.replace(&#39;data/&#39;,&#39;&#39;) label = label.replace(&#39;.tsv&#39;,&#39;&#39;) labelL.append(label) #print(label) header = 1 count = 3 #print(label) for line in open(file_name): if header == 1: header -= 1 continue #-------------------- lineL = line.strip().split(&#39;\\t&#39;) gene = lineL[0] FPKM = lineL[-1] aDict.setdefault(gene, {}) aDict[gene][label] = FPKM #if count: # print(&quot;\\t&quot;,aDict) # count -= 1 #-------------------------------------- print(&quot;GeneName&quot;, &#39;\\t&#39;.join(labelL), sep=&quot;\\t&quot;) count = 5 for gene,exprD in list(aDict.items()): exprL = [exprD.get(label, &#39;0&#39;) for label in labelL] exprL = [gene] + exprL #if count: print(&#39;\\t&#39;.join(exprL)) # count -= 1 GeneName ENCFF060LPA ENCFF262OBL ENCFF289HGQ ENCFF673KYR ENSG00000000003.14 18.24 26.74 10.84 15.07 ENSG00000000005.5 0.00 0.00 0.00 0.00 ENSG00000000419.12 27.19 29.44 15.23 11.17 ENSG00000000457.13 2.37 3.87 2.53 2.37 ENSG00000000460.16 4.14 8.37 2.70 0.98 for line in open(&quot;data/test2.fa&quot;): if line[0] == &#39;&gt;&#39;: &gt;NM_001011874 gene=Xkr4 CDS=151-2091 gcggcggcgggcgagcgggcgctggagtaggagctggggagcggcgcggccggggaaggaagccagggcg aggcgaggaggtggcgggaggaggagacagcagggacaggTGTCAGATAAAGGAGTGCTCTCCTCCGCTG CCGAGGCATCATGGCCGCTAAGTCAGACGGGAGGCTGAAGATGAAGAAGAGCAGCGACGTGGCGTTCACC CCGCTGCAGAACTCGGACAATTCGGGCTCTGTGCAAGGACTGGCTCCAGGCTTGCCGTCGGGGTCCGGAG &gt;NM_001195662 gene=Rp1 CDS=55-909 AAGCTCAGCCTTTGCTCAGATTCTCCTCTTGATGAAACAAAGGGATTTCTGCACATGCTTGAGAAATTGC AGGTCTCACCCAAAATGAGTGACACACCTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCA AGTTCCTTCCCCTCGCCATTCAAATATCACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGT GGAGACCCACAGTTTGGCGGCGTTCGGGTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGC TGGACAGTTTATCCAGGAAGGTACCCCTGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACA CAGCATCACCAGGCTGGAGGAGCTAGAGGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTG &gt;NM_011283 gene=Rp1 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC ACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACAC CTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATAT CACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGG GTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCC TGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGA GGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGG CGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATA TGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA &gt;NM_0112835 gene=Rp1 CDS=128-6412 AATAAATCCAAAGACATTTGTTTACGTGAAACAAGCAGGTTGCATATCCAGTGACGTTTATACAGACCAC ACAAACTATTTACTCTTTTCTTCGTAAGGAAAGGTTCAACTTCTGGTCTCACCCAAAATGAGTGACACAC CTTCTACTAGTTTCTCCATGATTCATCTGACTTCTGAAGGTCAAGTTCCTTCCCCTCGCCATTCAAATAT CACTCATCCTGTAGTGGCTAAACGCATCAGTTTCTATAAGAGTGGAGACCCACAGTTTGGCGGCGTTCGG GTGGTGGTCAACCCTCGTTCCTTTAAGACTTTTGACGCTCTGCTGGACAGTTTATCCAGGAAGGTACCCC TGCCCTTTGGGGTAAGGAACATCAGCACGCCCCGTGGACGACACAGCATCACCAGGCTGGAGGAGCTAGA GGACGGCAAGTCTTATGTGTGCTCCCACAATAAGAAGGTGCTGCCAGTTGACCTGGACAAGGCCCGCAGG CGCCCTCGGCCCTGGCTGAGTAGTCGCTCCATAAGCACGCATGTGCAGCTCTGTCCTGCAACTGCCAATA TGTCCACCATGGCACCTGGCATGCTCCGTGCCCCAAGGAGGCTCGTGGTCTTCCGGAATGGTGACCCGAA "],["references.html", "8 生信教程文章集锦 8.1 生信宝典 8.2 宏基因组", " 8 生信教程文章集锦 8.1 生信宝典 生信的作用越来越大，想学的人越来越多，不管是为了以后发展，还是为了解决眼下的问题。但生信学习不是一朝一夕就可以完成的事情，也许你可以很短时间学会一个交互式软件的操作，却不能看完程序教学视频后就直接写程序。也许你可以跟着一个测序分析流程完成操作，但不懂得背后的原理，不知道什么参数需要修改，结果可以出来，却把我不住对还是错。 学习生信从来就不是一个简单的事，需要做好持久战的心理准备。 在学习时，我们都希望由浅入深的逐步深入，不断地练习和实践，这就是为什么我们需要一本书，因为书很系统。但生信发展的历史短于计算机编程的历史，如果想要一门程序设计的入门数据，每种语言都可以找到几本。但想要一个囊括生信的书，就有些难了。本身生信跨领域，需要多学科的知识，而其内部又有不少分子，都囊括了太大，包括的少又有些隔靴搔痒的感觉。 我们当时都是零基础下自学Linux, 自学Python，自学R，自学高通量测序；这些学习经历，之前都零星地记录在博客里。现在回头去看几年前自己记录的东西，觉得好简单，而当时却费了很大的力气。这些零星的随手记，当时也只是为了自己看，到现在确实只有自己能看得懂，不便惠及更多的人。 因此我们创建了生信宝典，希望从不同的角度传播知识。这个不同有三点含义，一是形式上的不同，摒弃之前主编们单人作战想写啥就写啥，而是有组织有计划的内容聚合，提供一系列的教程，由入门到提高。二是内容的不同，不去用网上现有教程的通用数据做例子，而是拿实际生物数据，讲述如何解释生信中普遍碰到的问题，讲述如何处理自己的数据。三是立足点不同。在写作时，我们回到了当年，在回忆中用整个阶段的学习去指导当初的那个小白，从那些会了的人觉得微不足道而不会的人又迈不过的坎入手，直击痛点。知识点的收录依据不是是否炫酷，是否难，而是是否必要。如果必要，再简单，也要提及；如果不必要，再炫酷，也暂不纳入。 通过大量的生信例子、关键的注释和浓缩的语句形成下面的一系列学习教程。每一篇内容都不多，可以当做小说阅读，也可以跟着去练，反复几遍，每读一次都会有不同的收获和体会。 8.1.1 系列教程 生物信息之程序 如何优雅的提问 生信宝典视频教程 好色之旅-画图三字经 转录组分析的正确姿势 生信的系列教程 生信的系列书籍 文章用图的修改和排版 (1) 文章用图的修改和排版 (2) 简单强大的在线绘图 简单强大的在线绘图-升级版 论文图表基本规范 学术图表的基本配色方法 英语写作常见错误总结和学习视频 教育部推出首批490门“国家精品在线开放课程 8.1.2 NGS分析工具评估 39个转录组分析工具，120种组合评估(转录组分析工具哪家强-导读版) 39个转录组分析工具，120种组合评估(转录组分析工具大比拼 （完整翻译版）) 无参转录组分析工具评估和流程展示 8.1.3 宏基因组教程 微生物组入门必读+宏基因组实操课程 扩增子图表解读-理解文章思路 扩增子分析流程-把握分析细节 扩增子统计绘图-冲击高分文章 宏基因组分析教程 4500元的微生物组培训资料 8.1.4 系列宣传 转录组分析的正确姿势 120分的转录组考题，你能得多少 生物信息作图系列R、Cytoscape及图形排版和Python编程培训研讨班开课了 维密摔倒不可怕，关键时有人搀一把，坚持走下去 生物信息作图系列 - R、网络图及文章图形排版 易生信转录组培训总结和优惠分享 生物信息9天速成班 — 你也可以成为团队不可或缺的人 Python没有捷径，但可以加速，零基础九天你也可以会编程 小学生都学Python了，你还不知道怎么开始-资源帖 一个月学会Python的Quora指南和资料放送 扩增子分析基本流程和结果解读 微生物组——扩增子分析专题实战开课啦 如何入门生信Linux 3分和30分文章差距在哪里？ 8.1.5 生信生物知识 生物研究中不可缺少的数字概念，多少，多大，多快 8.1.6 文献精读 CRISPR-CAS9发展历程小记 一场大病引起的诺贝尔2017年生理学奖角逐 Science搞反狗脑 - 人脑和狗脑一样？ 一篇压根不存在的文献被引用400次？！揭开” 幽灵文献” 的真面目 基于人工智能的文献检索，导师查找，更聪明 GeenMedical：文献查询、筛选、引用排序、相似文献、全文下载、杂志分区、影响因子、结果导出、杂志评述、直接投稿，一站服务 YANDEX搜索，不翻墙稳定使用近谷歌搜索 Nature我的研究对后人毫无用途：21%的学术论文自发布后从未被引用 SCI-HUB镜像, SSH隧道访问学校内网 为了速成生物学，一位程序员探索了”爆款”基因背后的秘密 8.1.7 Linux Linux-总目录 Linux-文件和目录 Linux-文件操作 Linux文件内容操作 Linux-环境变量和可执行属性 Linux - 管道、标准输入输出 Linux - 命令运行监测和软件安装 Linux-常见错误和快捷操作 Linux-文件列太多，很难识别想要的信息在哪列；别焦急，看这里。 Linux-文件排序和FASTA文件操作 Linux-应用Docker安装软件 Linux服务器数据定期同步和备份方式 VIM的强大文本处理方法 Linux - Conda软件安装方法 查看服务器配置信息 Linux - SED操作，awk的姊妹篇 Linux - 常用和不太常用的实用awk命令 Bash概论 - Linux系列教程补充篇 8.1.8 CIRCOS系列 CIRCOS圈图绘制 - circos安装 CIRCOS圈图绘制 - 最简单绘图和解释 CIRCOS圈图绘制 - 染色体信息展示和调整 CIRCOS增加热图、点图、线图和区块属性 8.1.9 R统计和作图 在R中赞扬下努力工作的你，奖励一份CheatShet 别人的电子书，你的电子书，都在bookdown R语言 - 入门环境Rstudio R语言 - 热图绘制 (heatmap) R语言 - 基础概念和矩阵操作 R语言 - 热图简化 R语言 - 热图美化 R语言 - 线图绘制 R语言 - 线图一步法 R语言 - 箱线图（小提琴图、抖动图、区域散点图） R语言 - 箱线图一步法 R语言 - 火山图 R语言 - 富集分析泡泡图 （文末有彩蛋） R语言 - 散点图绘制 一文看懂PCA主成分分析 富集分析DotPlot，可以服 R语言 - 韦恩图 R语言 - 柱状图 R语言 - 图形设置中英字体 R语言 - 非参数法生存分析 基因共表达聚类分析和可视化 R中1010个热图绘制方法 还在用PCA降维？快学学大牛最爱的t-SNE算法吧, 附Python/R代码 一个函数抓取代谢组学权威数据库HMDB的所有表格数据 文章用图的修改和排版 network3D: 交互式桑基图 network3D 交互式网络生成 8.1.10 扩增子三步曲 1图表解读-理解文章思路 2分析流程-把握分析细节 扩展1：视频教程-夯实分析思路 扩展2：QIIME2教程-了解分析趋势 3统计绘图-冲击高分文章 8.1.11 宏基因组分析专题 1背景知识-Shell入门与本地blast实战 2数据质控fastqc, Trimmomatic, MultiQC, khmer 3组装拼接MEGAHIT和评估quast 4基因注释Prokka 5基于Kmer比较数据集sourmash 6不比对快速估计基因丰度Salmon 7bwa序列比对, samtools查看, bedtools丰度统计 8分箱宏基因组binning, MaxBin, MetaBin, VizBin 9组装assembly和分箱bin结果可视化—Anvio 10绘制圈图-Circos安装与使用 MetaPhlAn2分析有参宏基因组 8.1.12 NGS基础 NGS基础 - FASTQ格式解释和质量评估 NGS基础 - 高通量测序原理 NGS基础 - 参考基因组和基因注释文件 NGS基础 - GTF/GFF文件格式解读和转换 本地安装UCSC基因组浏览器 测序数据可视化 (一) 测序文章数据上传找哪里 GO、GSEA富集分析一网打进 GSEA富集分析 - 界面操作 去东方，最好用的在线GO富集分析工具 生信软件系列 - NCBI使用 8.1.13 癌症数据库 UCSC XENA - 集大成者(TCGA, ICGC) ICGC数据库使用 TCGA数据库在线使用 8.1.14 Python Python学习 - 可视化变量赋值、循环、程序运行过程 Python极简教程 （一） Python教程（二） Python教程（三） Python教程 （四） Python教程（五） Python教程 （六） Pandas，让Python像R一样处理数据，但快 Python解析psiBlast输出的JSON文件结果 为啥我的Python这么慢 - 项查找 (二) 为啥我的Python这么慢 (一) Python资源 关于Python中的__main__和编程模板 8.1.15 NGS软件 Rfam 12.0+本地使用 （最新版教程） 轻松绘制各种Venn图 ETE构建、绘制进化树 psRobot：植物小RNA分析系统 生信软件系列 - NCBI使用 去东方，最好用的在线GO富集分析工具 8.1.16 Cytoscape网络图 Cytoscape教程1 Cytoscape之操作界面介绍 新出炉的Cytoscape视频教程 8.1.17 分子对接 来一场蛋白和小分子的风花雪月 不是原配也可以-对接非原生配体 简单可视化-送你一双发现美的眼睛 你需要知道的那些前奏 8.1.18 生信宝典之傻瓜式 生信宝典之傻瓜式 (一) 如何提取指定位置的基因组序列 生信宝典之傻瓜式 (二) 如何快速查找指定基因的调控网络 生信宝典之傻瓜式 (三) 我的基因在哪里发光 - 如何查找基因在发表研究中的表达 生信宝典之傻瓜式 (四) 蛋白蛋白互作网络在线搜索 生信宝典之傻瓜式 (五) 文献挖掘查找指定基因调控网络 8.1.19 生信人写程序 生信人写程序1. Perl语言模板及配置 生信人写程序2. Editplus添加Perl, Shell, R, markdown模板和语法高亮 8.1.20 小技巧系列 参考文献中杂志名字格式混乱问题一次解决 8.1.21 招聘 易汉博欢迎您加入 8.2 宏基因组 http://mp.weixin.qq.com/s/5jQspEvH5_4Xmart22gjMA 宏基因组/微生物组是当今世界科研最热门的研究领域之一，为加强本领域的技术交流与传播，推动中国微生物组计划发展，中科院青年科研人员创立“宏基因组”公众号，目标为打造本领域纯干货技术及思想交流平台。 本公众号每日推送，工作日分享宏基因组领域科研思路、实验和分析技术，理论过硬实战强；周末科普和生活专栏，轻松读文看片涨姿势。目前经过近半年发展，分享过百篇原创文章，已有14000+小伙伴在这里一起交流学习，感兴趣的赶快关注吧。 8.2.1 精选文章推荐 5000+ 微生物组入门必读+宏基因组实操课程 你想要的生信知识全在这—生信宝典 生物信息9天速成班—成为团队不可或缺的人 3分和30分文章差距在哪里？ 肠道菌群在人体中的作用 看完此片我想把身上的细菌寄生虫供起来 岛国科普—生命大跃进 我们的未来在哪里？ 论文图表基本规范 DNA提取发Nature 实验vs数据分析，谁对结果影响大? 3000+ 扩增子图表解读-理解文章思路 扩增子分析流程-把握分析细节 扩增子统计绘图-冲击高分文章 宏基因组分析教程 4500元的微生物组培训资料 Co-occurrence网络图在R中的实现 学术图表的基本配色方法 一文读懂进化树 自学生信-biostar handbook 漱口水增加糖尿病，高血压风险 1000+ 微生物组——扩增子分析专题培训开课啦！！！ 最简单漂亮的免费在线生信绘图工具 小学生都学Python了，你还不知道怎么开始 五彩进化树与热图更配-ggtree美颜进化树 扩增子分析还聚OTU就真OUT了 主流非聚类方法dada2,deblur和unoise3介绍与比较 16S预测微生物群落功能 0概述 1KO通路PICRUSt 2元素循环FAPROTAX 3表型bugbase 4KO通路Tax4Fun 一文读懂微生物组 2017年发展简史和十大热文盘点 8.2.2 培训、会议、征稿、招聘 3月10-19日，北京，微生物组——扩增子分析专题培训 5月11-13日，北京，中国肠道大会 8.2.3 科研经验 如何优雅的提问 公众号搜索方法大全 科研团队成长三部曲：1云笔记 2云协作 3公众号 文献阅读 1热心肠 2SemanticScholar 3geenmedical 生信编程模板 Perl Shell R 生物信息之程序学习 Endnote X8云同步：有网随时读文献 论文Figures，你不能不知道的秘密 转录组分析的正确姿势 整个世界都是你的已知条件 8.2.4 软件和数据库使用 SILVAngs:16S/18S在线分析1 2 METAGENassist帮你搞定宏基因分析的所有图形需求 Windows不用虚拟机或双系统，轻松实现linux shell环境：gitforwindows 一条命令轻松绘制CNS顶级配图-ggpubr ggbiplot-最好看的PCA图 LDA分析、作图及添加置信-ggord ggrepel-解决散点图样品标签重叠，方便筛选样品 Alpha多样性稀释曲线rarefraction curve 微生物组间差异分析神器-STAMP 扩增子分析神器USEARCH 微生物扩增子数据库大全 antiSMASH：微生物次生代谢物基因簇预测 微生物网络构建：MENA, LSA, SparCC和CoNet Cytoscape: MCODE增强包的网络模块化分析 FUNGuild：真菌功能注释 在线RaxML构建系统发育树 Genevestigator: 查找基因在发表研究中的表达 psRobot：植物小RNA分析系统 RepeatMasker：基因组重复序列注释 8.2.5 扩增子学习三步曲 8.2.5.1 1图表解读-理解文章思路 8.2.5.2 2分析流程-把握分析细节 扩展1：视频教程-夯实分析思路 扩展2：QIIME2教程-了解分析趋势 8.2.5.3 3统计绘图-冲击高分文章 8.2.6 宏基因组分析专题 1背景知识-Shell入门与本地blast实战 2数据质控fastqc, Trimmomatic, MultiQC, khmer 3组装拼接MEGAHIT和评估quast 4基因注释Prokka 5基于Kmer比较数据集sourmash 6不比对快速估计基因丰度Salmon 7bwa序列比对, samtools查看, bedtools丰度统计 8分箱宏基因组binning, MaxBin, MetaBin, VizBin 9组装assembly和分箱bin结果可视化—Anvi’o 10绘制圈图-Circos安装与使用 MetaPhlAn2分析有参宏基因组 8.2.7 R统计绘图 视频教程：R语言recharts包绘制交互式图形 R语言聚类分析–cluster, factoextra 堆叠柱状图各成分连线画法：突出展示组间物种丰度变化 R相关矩阵可视化包ggcorrplot 8.2.8 实验设计与技术 微生物样本取样及微生物基因组DNA提取建议 样品生物学重复数据选择 1必要性 2需要多少重复？ 样品命名 注意事项 扩增子引物选择 16S结构 16S单V4区是最佳选择? 海洋可培养微生物的鉴定与分类 怎么取粪便样品 Rhizosphere、Rhizoplane根际土如何取 Nat. Biotechnol.扩增子测序革命—用16S及18S rRNA全长进行微生物多样性研究 8.2.9 基础知识 Microbiota, metagenome, microbiome区别 16S测序，不知道OTU你就out了！ 计量宏基因组学数据分析的方法及进展 排序方法比较大全PCA、PCoA、NMDS、CCA LEfSe分析，你真的懂了么 宏基因组基础知识梳理 扩增子SCI套路1微群落结构差异 2组间差异分析 3系统总结 环境因子关联分析——我应该选择CCA还是RDA分析？ “P值”背后那些不可不知的事儿 Adonis和ANOSIM方法组间整体差异评估原理 轻松看懂机器学习十大常用算法 一文读懂“随机森林”在微生态中的应用 你想知道的“ROC曲线” 人体对微生物的管控 简单读懂微生物基因组的泛基因组学 8.2.10 必读综述 Nature：宏基因组关联分析 Nature：肠道菌群如何划分肠型 Nature: 来自细菌的通告——群感效应简介 Nature：呼吸道菌群—呼吸道健康的守门人 Nature: 拥抱未知-解析土壤微生物组的复杂性 Cell：代谢控制中的脑肠轴 研究微生物，只靠多组学根本不够 中国微生物组计划—农作物微生物组 Annu Rev：植物微生物组—系统见解与展望 Annual Reviews|微生物组与人 微生物组学与植物病害微生物防治 组学重建真菌现有分类系统 微生物应用|农业废弃物资源化利用 宏基因组学入门1初识 2进一步 3拼接 肠道微生物与人类密切相关的方方面面 Nature: 测序技术的前世今生 Nature Reviews：全新的益生元定义和范围 原核转录组非编码RNA研究 8.2.11 高分文章套路解读 Nature: 培养组学—高通量细菌分离培养鉴定 SR: 真菌培养组学同揭示人类肠道真菌群落结构 Nature: 地球微生物组计划首发成果—揭示地球多尺度微生物多样性 Nature：如何做一篇肠道菌群免疫的顶级文章 Nat Biotech: 宏表观组—DNA甲基化辅助宏基因组binning Nature: 甘露糖苷选择性抑制致病性大肠杆菌 Nature: 拟南芥根微生物组的结构和组成 Nature: 地球上最古老的热液喷口发现早期生命迹象 Nature Method: 宏基因组软件评估—人工重组宏基因组基准数据集 Nature Genetics：微生物基因组如何适应植物？(news &amp; views) NC：降低微生物群落复杂度突破组装难题 NC：自体免疫水泡皮肤病中鉴定基因与微生物组互作 GigaScience:植物MWAS研究—谷子产量与微生物组关联分析 Microbiome：微生物组研究中你必须注意的细节 Microbiome：HiSeq平台16S扩增子文库构建方法 Microbiome: 简单套路发高分文章–杨树微生物组 Microbiome：肠道菌群失衡促进高血压 Microbiome：重新定义“卫生”概念 ME：网络分析揭示微生物群落应对环境扰动的稳定性机制 SR: 土壤细菌定量方法结合相对丰度分析揭示种群的真实变化 8.2.12 科普视频-寓教于乐 BBC人体奥秘之细胞的暗战 BBC人体奥秘 Inside.the.Human.Body NG人体内旅行Inside.the.Living.Body NG子宫日记 Womb NHK: 再造人类生命的神奇细胞 CCTV9让尸体说话-法医密档 豆瓣8.9，惹哭亿万中国人的纪录片-本草中华 2分钟视频回顾植物学家钟扬的贡献 一顿“寄生虫大餐”，或能治好干净引来的免疫病 只要11天，浓度1000倍的抗生素也无效——超级细菌 致命病毒为何疯狂袭击人类？都怪我们那群会飞的远房亲戚 土豆上的小霉菌引发百万人死亡和逃难，却造就全球7千万后裔 看完这些能控制大脑的寄生虫，你会怀疑人类！ 梅毒狂想曲 8.2.13 友军文章汇总推荐 学习生信的系列教程——纯生信一作发IF&gt;20的大神 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
